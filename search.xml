<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>workflow</title>
    <url>/uncategorized/plan/plan/</url>
    <content><![CDATA[<h2 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h2><p>Workflow的src&#x2F;kernel目录里，包含了以下独立的模块，基本都是C和简单C++语法实现的，没有复杂的语法，每一个模块都很小，都可以单独拿出来学习：</p>
<p>poller,可以学习如何使用epoll<br>thrdpool,经典线程池实现<br>msgqueue,消息队列实现<br>Communicator,异步网络通信器，包括了基本的目标管理和负载均衡<br>Executor,包含计算调度算法的执行器<br>IO_Service,异步文件IO</p>
]]></content>
  </entry>
  <entry>
    <title>Git的指令</title>
    <url>/uncategorized/%E7%AC%94%E8%AE%B0/git/</url>
    <content><![CDATA[<h2 id="Git的指令"><a href="#Git的指令" class="headerlink" title="Git的指令"></a>Git的指令</h2><ul>
<li>git init: 初始化git</li>
<li>git add : 添加所有文件到暂存区<ul>
<li>git add 文件名/文件夹: 添加指定文件到暂存区 </li>
<li>git add . : 添加当前目录下的所有文件到暂存区</li>
</ul>
</li>
<li>git commit -m “提交信息”: 提交暂存区到版本库</li>
<li>git log: 查看提交记录<ul>
<li>git log —oneline: 查看提交记录的简略信息</li>
</ul>
</li>
<li>git status: 查看当前工作区状态 </li>
<li>git reset —hard 版本号: 回滚到指定版本<ul>
<li>git reset —hard HEAD^: 回滚到上一个版本 </li>
</ul>
</li>
<li>git reflog: 查看所有操作记录</li>
<li>git branch ：查看当前版本库所有分支，绿色带*代表现在所处的分支</li>
<li>git branch 分支名  ：创建分支</li>
<li>git checkout 分支名 ：切换分支</li>
<li>git merge 目标分支名  ：将目标分支合并到当前分支</li>
<li>git branch -d 分支名  ：删除分支</li>
<li>git remote add origin <a href="https://github.com/username/repository.git">https://github.com/username/repository.git</a>: 添加远程仓库</li>
<li>git push origin master: 将本地仓库推送到远程仓库</li>
<li>git config —list : 查看配置信息</li>
<li>git config —global unset user.name : 删除全局配置信息重点user.name</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/uncategorized/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/</url>
    <content><![CDATA[<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><ol>
<li><p>查看 mysql 服务状态<br>sudo service mysql status</p>
</li>
<li><p>启动 mysql 服务<br>sudo service mysql start</p>
</li>
</ol>
<h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><ol>
<li><p>登录数据库<br>mysql -u root -p</p>
</li>
<li><p>退出数据库<br>exit&#x2F;quit</p>
</li>
</ol>
<h1 id="使用mysql"><a href="#使用mysql" class="headerlink" title="使用mysql"></a>使用mysql</h1><ol>
<li><p>选择数据库<br>USE 数据库名;</p>
</li>
<li><p>显示所有数据库<br>SHOW DATABASES;</p>
</li>
<li><p>显示当前数据库的列表<br>SHOW TABLES;</p>
</li>
<li><p>显示表字段<br>SHOW COLUMNS FROM 表名;</p>
<ol>
<li>表字段（等价方式）<br>DESCRIBE 表名;</li>
</ol>
</li>
<li><p>查看服务器状态（健康报告）<br>SHOW STATUS;</p>
</li>
<li><p>查看创建数据库的 SQL 语句<br>SHOW CREATE DATABASE 数据库名;</p>
</li>
<li><p>查看创建表的 SQL 语句<br>SHOW CREATE TABLE 表名;</p>
</li>
<li><p>查看上一次语句的错误<br>SHOW ERRORS;</p>
</li>
<li><p>查看上一次语句的警告<br>SHOW WARNINGS;</p>
</li>
</ol>
<h1 id="补充1"><a href="#补充1" class="headerlink" title="补充1"></a>补充1</h1><ol>
<li><p>创建数据库<br>CREATE DATABASE 数据库名;</p>
</li>
<li><p>删除数据库<br>DROP DATABASE 数据库名;</p>
</li>
<li><p>创建表<br>CREATE TABLE 表名 (<br>   字段名 字段类型 约束,<br>   字段名 字段类型 约束,<br>   …<br>);</p>
</li>
<li><p>插入数据<br>INSERT INTO 表名 (字段名, 字段名, …) VALUES (值, 值, …);</p>
</li>
<li><p>添加字段（可选 COLUMN,表示添加新的字段）<br>ALTER TABLE 表名 ADD COLUMN 字段名 数据类型 [其他约束];</p>
<blockquote>
<p>ALTER TABLE products ADD number INT;</p>
</blockquote>
</li>
<li><p>添加约束（CONSTRAINT可选,表示添加约束）<br>ALTER TABLE 表名 ADD CONSTRAINT 约束名 约束类型 (字段名);</p>
<blockquote>
<p>ALTER TABLE products ADD PRIMARY KEY (prod_id);</p>
</blockquote>
</li>
<li><p>修改数据<br>UPDATE 表名 SET 列名 &#x3D; 新值 WHERE 条件;</p>
<ol>
<li><p>单条更新示例  </p>
<blockquote>
<p>UPDATE products SET money &#x3D; 20 WHERE id &#x3D; 1;<br>UPDATE products SET number &#x3D; 0 WHERE number IS NULL;</p>
</blockquote>
</li>
<li><p>批量更新示例  </p>
<blockquote>
<p>UPDATE products<br>SET money &#x3D; CASE id<br>WHEN 1 THEN 20<br>WHEN 2 THEN 30<br>ELSE money<br>END;</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="📦-常见-SQL-数据类型"><a href="#📦-常见-SQL-数据类型" class="headerlink" title="📦 常见 SQL 数据类型"></a>📦 常见 SQL 数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>INT</code> &#x2F; <code>INTEGER</code></td>
<td>整数类型，常用于 ID、数量等。可加 <code>UNSIGNED</code> 表示非负。</td>
</tr>
<tr>
<td><code>SMALLINT</code></td>
<td>占用更小空间的整数，适合范围小的值。</td>
</tr>
<tr>
<td><code>BIGINT</code></td>
<td>用于非常大的整数，如用户量巨大的系统。</td>
</tr>
<tr>
<td><code>FLOAT</code> &#x2F; <code>DOUBLE</code></td>
<td>浮点数，适合温度、速度等有小数的值。</td>
</tr>
<tr>
<td><code>DECIMAL(p, s)</code></td>
<td>精确浮点数，常用于金融，<code>p</code> 为总位数，<code>s</code> 为小数位数。</td>
</tr>
<tr>
<td><code>CHAR(n)</code></td>
<td>定长字符串，固定为 <code>n</code> 个字符，适合身份证号等。</td>
</tr>
<tr>
<td><code>VARCHAR(n)</code></td>
<td>可变长度字符串，最多 <code>n</code> 个字符，适合姓名、地址等。</td>
</tr>
<tr>
<td><code>TEXT</code></td>
<td>长文本，适合存放文章、备注等内容。</td>
</tr>
<tr>
<td><code>DATE</code></td>
<td>日期类型，格式 <code>YYYY-MM-DD</code>。</td>
</tr>
<tr>
<td><code>TIME</code></td>
<td>时间类型，格式 <code>HH:MM:SS</code>。</td>
</tr>
<tr>
<td><code>DATETIME</code></td>
<td>日期 + 时间，格式 <code>YYYY-MM-DD HH:MM:SS</code>。</td>
</tr>
<tr>
<td><code>BOOLEAN</code></td>
<td>布尔类型，<code>TRUE</code> 或 <code>FALSE</code>，有些数据库用 <code>1/0</code>。</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧱-常见-SQL-约束"><a href="#🧱-常见-SQL-约束" class="headerlink" title="🧱 常见 SQL 约束"></a>🧱 常见 SQL 约束</h2><table>
<thead>
<tr>
<th>约束关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>PRIMARY KEY</code></td>
<td>主键，唯一标识每一行记录，不能重复也不能为空。</td>
</tr>
<tr>
<td><code>NOT NULL</code></td>
<td>不允许为空，必须有值。</td>
</tr>
<tr>
<td><code>UNIQUE</code></td>
<td>值必须唯一，不可重复。</td>
</tr>
<tr>
<td><code>DEFAULT</code></td>
<td>指定默认值，插入时未指定则使用该值。</td>
</tr>
<tr>
<td><code>CHECK (条件)</code></td>
<td>添加条件限制，数据必须满足该条件。</td>
</tr>
<tr>
<td><code>FOREIGN KEY</code></td>
<td>外键，用于关联其他表的主键，建立表之间的关系。</td>
</tr>
</tbody></table>
<hr>
<h1 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h1><ol>
<li><p>检索一个或多个列<br>SELECT 字段名 FROM 表名;</p>
<blockquote>
<p>SELECT prod_name<br>FROM products;</p>
</blockquote>
</li>
<li><p>检索所有列<br>SELECT * FROM 表名;</p>
<blockquote>
<p>SELECT *<br>FROM products;</p>
</blockquote>
</li>
<li><p>笛卡尔积分</p>
<p>SELECT 字段名 FROM 表名1, 表名2;</p>
<blockquote>
<p>SELECT *<br>FROM products, categories;</p>
</blockquote>
</li>
<li><p>检索不同的列<br>SELECT DISTINCT 字段名 FROM 表名;</p>
<blockquote>
<p>SELECT DISTINCT prod_name<br>FROM products;</p>
</blockquote>
</li>
<li><p>检索指定数量的记录<br>SELECT 字段名 FROM 表名 LIMIT 值;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>LIMIT 3;</p>
</blockquote>
<ol>
<li><p>从指定偏移开始检索<br>SELECT 字段名 FROM 表名 LIMIT 值 OFFSET 值;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>LIMIT 3 OFFSET 2;</p>
</blockquote>
</li>
<li><p>WHERE 条件加偏移检索<br>SELECT 字段名 FROM 表名 WHERE 条件 LIMIT 偏移,数量;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>LIMIT 3,2;</p>
</blockquote>
</li>
</ol>
</li>
<li><p>检索指定表的列<br>SELECT 表名.字段名 FROM 表名;</p>
</li>
</ol>
<h1 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h1><ol>
<li><p>默认升序排序<br>SELECT 字段名 FROM 表名 ORDER BY 字段名;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>ORDER BY money;</p>
</blockquote>
</li>
<li><p>降序排序<br>SELECT 字段名 FROM 表名 ORDER BY 字段名 DESC;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>ORDER BY money DESC;</p>
</blockquote>
</li>
<li><p>多字段混合排序<br>SELECT 字段名 FROM 表名 ORDER BY 字段名 ASC, 字段名 DESC;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>ORDER BY money ASC, number DESC;</p>
</blockquote>
</li>
<li><p>排序并限制数量<br>SELECT 字段名 FROM 表名 ORDER BY 字段名 DESC LIMIT 值;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>ORDER BY money DESC<br>LIMIT 3;</p>
</blockquote>
</li>
</ol>
<h1 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h1><ol>
<li><p>检索满足条件的数据<br>SELECT 字段名 FROM 表名 WHERE 条件;</p>
<ul>
<li><p>支持运算符：<code>&gt;</code>、<code>&lt;</code>、<code>=</code>、<code>!=</code>、<code>&lt;&gt;</code>、<code>&gt;=</code>、<code>&lt;=</code></p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE money &#x3D; 20;</p>
</blockquote>
</li>
<li><p>范围检索<br>SELECT 字段名 FROM 表名 WHERE 字段名 BETWEEN 值1 AND 值2;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE money BETWEEN 10 AND 20;</p>
</blockquote>
</li>
</ul>
</li>
<li><p>检索为空的数据<br>SELECT 字段名 FROM 表名 WHERE 字段名 IS NULL;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE nickname IS NULL;</p>
</blockquote>
</li>
</ol>
<h1 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h1><ol>
<li><p>满足所有条件（AND）<br>SELECT 字段名 FROM 表名 WHERE 条件1 AND 条件2;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE prod_name &#x3D; ‘shangping1’ AND money &#x3D; 20;</p>
</blockquote>
</li>
<li><p>满足任一条件（OR）<br>SELECT 字段名 FROM 表名 WHERE 条件1 OR 条件2;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE prod_name &#x3D; ‘shangping1’ OR money &#x3D; 20;</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>注意：AND 优先级高于 OR</p>
</blockquote>
<ol start="3">
<li><p>指定值检索<br>SELECT 字段名 FROM 表名 WHERE 字段名 IN (值1, 值2, …);</p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE prod_name IN (‘shangping1’, ‘shangping2’);</p>
</blockquote>
</li>
<li><p>排除指定值<br>SELECT 字段名 FROM 表名 WHERE 字段名 NOT IN (值1, 值2, …);</p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE prod_name NOT IN (‘shangping1’);</p>
</blockquote>
</li>
</ol>
<h1 id="用通配符进行过滤"><a href="#用通配符进行过滤" class="headerlink" title="用通配符进行过滤"></a>用通配符进行过滤</h1><ol>
<li><p><code>%</code>：匹配任意数量的字符</p>
<ol>
<li><p>检索以指定值开头的数据<br>SELECT 字段名 FROM 表名 WHERE 字段名 LIKE ‘值%’;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE prod_name LIKE ‘shangping%’;</p>
</blockquote>
</li>
<li><p>检索以指定值结尾的数据<br>SELECT 字段名 FROM 表名 WHERE 字段名 LIKE ‘%值’;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE prod_name LIKE ‘%ping1’;</p>
</blockquote>
</li>
<li><p>检索包含指定值的数据<br>SELECT 字段名 FROM 表名 WHERE 字段名 LIKE ‘%值%’;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE prod_name LIKE ‘%ping%’;</p>
</blockquote>
</li>
</ol>
</li>
<li><p><code>_</code>：匹配单个字符</p>
<ol>
<li><p>检索以指定值开头的数据<br>SELECT 字段名 FROM 表名 WHERE 字段名 LIKE ‘值_’;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE prod_name LIKE ‘shangping_’;</p>
</blockquote>
</li>
<li><p>同上<br>（与上面命令一致，只匹配单个字符）</p>
</li>
</ol>
</li>
</ol>
<h1 id="使用正则表达式进行搜索"><a href="#使用正则表达式进行搜索" class="headerlink" title="使用正则表达式进行搜索"></a>使用正则表达式进行搜索</h1><ol>
<li><p><code>REGEXP</code>：使用正则表达式进行搜索<br>SELECT 字段名 FROM 表名 WHERE 字段名 REGEXP ‘正则表达式’;</p>
</li>
<li><p>‘.’: 匹配任意一个字符<br>SELECT 字段名 FROM 表名 WHERE 字段名 REGEXP ‘.shanghai.’;</p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE prod_name REGEXP ‘shangping.’;</p>
</blockquote>
</li>
<li><p>‘|’: 表示或<br>SELECT 字段名 FROM 表名 WHERE 字段名 REGEXP ‘shanghai|beijing’;   匹配上海或北京</p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE prod_name REGEXP ‘shangping2|shangping1’;</p>
</blockquote>
</li>
<li><p>[123..]: 相当于1 | 2 | 3…（字母也行）<br>SELECT 字段名 FROM 表名 WHERE 字段名 REGEXP ‘[123]’;   匹配1或2或3</p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE prod_name REGEXP ‘[123]’;</p>
</blockquote>
</li>
<li><p>SELECT 字段名 FROM 表名 WHERE 字段名 REGEXP ‘<a href="%E5%8C%B9%E9%85%8D1%E5%88%B08%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E5%AD%97%E6%AF%8D%E4%B9%9F%E8%A1%8C%EF%BC%89">1-8</a>‘;   匹配1到8之间的数字</p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE prod_name REGEXP ‘<a href="%E5%8C%B9%E9%85%8D1%E5%88%B08%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%88%E5%AD%97%E6%AF%8D%E4%B9%9F%E8%A1%8C%EF%BC%89">1-8</a>‘;</p>
</blockquote>
</li>
<li><p>特殊字符</p>
<ol>
<li><p>‘.’:\\.<br>SELECT 字段名 FROM 表名 WHERE 字段名 REGEXP ‘\.’;       匹配包含.的表项</p>
<blockquote>
<p>SELECT *<br>FROM products<br>WHERE prod_name REGEXP “\\.”;</p>
</blockquote>
</li>
<li><p>\\\:\</p>
</li>
<li><p>匹配空白元字符</p>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\f</td>
<td>换页</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
</tr>
<tr>
<td>\t</td>
<td>制表</td>
</tr>
<tr>
<td>\v</td>
<td>纵向制表</td>
</tr>
</tbody></table>
<ol start="4">
<li>匹配字符类</li>
</ol>
<table>
<thead>
<tr>
<th>类</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>[:alnum:]</td>
<td>任意字母和数字（同[a-zA-Z0-9]）</td>
</tr>
<tr>
<td>[:alpha:]</td>
<td>任意字母（同[a-zA-Z]）</td>
</tr>
<tr>
<td>[:blank:]</td>
<td>空格和制表（同[\t]）</td>
</tr>
<tr>
<td>[:cntrl:]</td>
<td>ASCII控制字符（ASCII 0到31和127）</td>
</tr>
<tr>
<td>[:digit:]</td>
<td>任意数字（同[0-9]）</td>
</tr>
<tr>
<td>[:graph:]</td>
<td>与[:print:]相同，但不包括空格</td>
</tr>
<tr>
<td>[:lower:]</td>
<td>任意小写字母（同[a-z]）</td>
</tr>
<tr>
<td>[:print:]</td>
<td>任意可打印字符</td>
</tr>
<tr>
<td>[:punct:]</td>
<td>既不在[:alnum:]又不在[:cntrl:]中的任意字符</td>
</tr>
<tr>
<td>[:space:]</td>
<td>包括空格在内的任意空白字符（同[\f\n\r\t\v]）</td>
</tr>
<tr>
<td>[:upper:]</td>
<td>任意大写字母（同[A-Z]）</td>
</tr>
<tr>
<td>[:xdigit:]</td>
<td>任意十六进制数字（同[a-fA-F0-9]）</td>
</tr>
</tbody></table>
<ol start="5">
<li>重复元字符</li>
</ol>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说  明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>0个或多个匹配</td>
</tr>
<tr>
<td>+</td>
<td>1个或多个匹配（等于{1,}）</td>
</tr>
<tr>
<td>?</td>
<td>0个或1个匹配（等于{0,1}）</td>
</tr>
<tr>
<td>{n}</td>
<td>指定数目的匹配</td>
</tr>
<tr>
<td>{n,}</td>
<td>不少于指定数目的匹配</td>
</tr>
<tr>
<td>{n,m}</td>
<td>匹配数目的范围（m不超过255）</td>
</tr>
</tbody></table>
<ol start="6">
<li>定位元字符</li>
</ol>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>文本的开始</td>
</tr>
<tr>
<td>$</td>
<td>文本的结尾</td>
</tr>
<tr>
<td>[[:&lt;:]]</td>
<td>词的开始</td>
</tr>
<tr>
<td>[[:&gt;:]]</td>
<td>词的结尾</td>
</tr>
</tbody></table>
<ol start="7">
<li>例子<br>   SELECT *<br>   FROM products<br>   WHERE prod_name REGEXP ‘[:digit:]$’;   匹配以数字结尾的prod_name</li>
</ol>
<h1 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h1><ol>
<li>Concat 函数：连接字符串<br>SELECT Concat(字段1，’(‘,字段2,’)’) FROM 表名;  检索结果为字段1（字段2）<blockquote>
<p>SELECT Concat(prod_name,’(‘,prod_price,’)’) FROM products;</p>
</blockquote>
</li>
<li>AS 关键字：创建计算字段<br>SELECT Concat(字段1，’(‘,字段2,’)’) AS 字段 FROM 表名;  检索结果为字段：字段1（字段2）<blockquote>
<p>SELECT Concat(prod_name,’(‘,prod_price,’)’) AS sale_price FROM products;</p>
</blockquote>
</li>
<li>算法计算<br>SELECT 字段1, 字段2, 字段1 +-*&#x2F; 字段2 AS 字段3 FROM 表名;   检索结果为字段1，字段2,字段3:字段1 + 字段2<blockquote>
<p>SELECT prod_name, prod_price, prod_price * 1.2 AS sale_price FROM products;</p>
</blockquote>
</li>
<li>奇技淫巧<ol>
<li>获取当前时间<br>SELECT Now();</li>
</ol>
</li>
</ol>
<h1 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h1><ol>
<li>常用的文本处理函数</li>
</ol>
<table>
<thead>
<tr>
<th>函 数</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>Left()</td>
<td>返回串左边的字符</td>
</tr>
<tr>
<td>Length()</td>
<td>返回串的长度</td>
</tr>
<tr>
<td>Locate()</td>
<td>找出串的一个子串</td>
</tr>
<tr>
<td>Lower()</td>
<td>将串转换为小写</td>
</tr>
<tr>
<td>LTrim()</td>
<td>去掉串左边的空格</td>
</tr>
<tr>
<td>Right()</td>
<td>返回串右边的字符</td>
</tr>
<tr>
<td>RTrim()</td>
<td>去掉串右边的空格</td>
</tr>
<tr>
<td>Soundex()</td>
<td>返回串的SOUNDEX值</td>
</tr>
<tr>
<td>SubString()</td>
<td>返回子串的字符</td>
</tr>
<tr>
<td>Upper()</td>
<td>将串转换为大写</td>
</tr>
</tbody></table>
<ol start="2">
<li>常用日期和时间处理函数</li>
</ol>
<table>
<thead>
<tr>
<th>函 数</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>AddDate()</td>
<td>增加一个日期（天、周等）</td>
</tr>
<tr>
<td>AddTime()</td>
<td>增加一个时间（时、分等）</td>
</tr>
<tr>
<td>CurDate()</td>
<td>返回当前日期</td>
</tr>
<tr>
<td>CurTime()</td>
<td>返回当前时间</td>
</tr>
<tr>
<td>Date()</td>
<td>返回日期时间的日期部分</td>
</tr>
<tr>
<td>DateDiff()</td>
<td>计算两个日期之差</td>
</tr>
<tr>
<td>Date_Add()</td>
<td>高度灵活的日期运算函数</td>
</tr>
<tr>
<td>Date_Format()</td>
<td>返回一个格式化的日期或时间串</td>
</tr>
<tr>
<td>Day()</td>
<td>返回一个日期的天数部分</td>
</tr>
<tr>
<td>DayOfWeek()</td>
<td>对于一个日期，返回对应的星期几</td>
</tr>
<tr>
<td>Hour()</td>
<td>返回一个时间的小时部分</td>
</tr>
<tr>
<td>Minute()</td>
<td>返回一个时间的分钟部分</td>
</tr>
<tr>
<td>Month()</td>
<td>返回一个日期的月份部分</td>
</tr>
<tr>
<td>Now()</td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td>Second()</td>
<td>返回一个时间的秒部分</td>
</tr>
<tr>
<td>Time()</td>
<td>返回一个日期时间的时间部分</td>
</tr>
<tr>
<td>Year()</td>
<td>返回一个日期的年份部分</td>
</tr>
</tbody></table>
<ol start="3">
<li>常用数值处理函数</li>
</ol>
<table>
<thead>
<tr>
<th>函 数</th>
<th>说 明</th>
</tr>
</thead>
<tbody><tr>
<td>Abs()</td>
<td>返回一个数的绝对值</td>
</tr>
<tr>
<td>Cos()</td>
<td>返回一个角度的余弦</td>
</tr>
<tr>
<td>Exp()</td>
<td>返回一个数的指数值</td>
</tr>
<tr>
<td>Mod()</td>
<td>返回除操作的余数</td>
</tr>
<tr>
<td>Pi()</td>
<td>返回圆周率</td>
</tr>
<tr>
<td>Rand()</td>
<td>返回一个随机数</td>
</tr>
<tr>
<td>Sin()</td>
<td>返回一个角度的正弦</td>
</tr>
<tr>
<td>Sqrt()</td>
<td>返回一个数的平方根</td>
</tr>
<tr>
<td>Tan()</td>
<td>返回一个角度的正切</td>
</tr>
</tbody></table>
<h1 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h1><ol>
<li>AVG 函数：计算平均值<br>SELECT AVG(字段) FROM 表名;<blockquote>
<p>SELECT AVG(prod_price) FROM products;</p>
</blockquote>
</li>
<li>COUNT 函数：计算行数<br>SELECT COUNT(字段) FROM 表名; <blockquote>
<p>SELECT COUNT(prod_name) FROM products;</p>
</blockquote>
</li>
<li>MAX 函数：计算最大值<br>SELECT MAX(字段) FROM 表名; <blockquote>
<p>SELECT MAX(prod_price) FROM products;</p>
</blockquote>
</li>
<li>MIN 函数：计算最小值<br>SELECT MIN(字段) FROM 表名;<blockquote>
<p>SELECT MIN(prod_price) FROM products;</p>
</blockquote>
</li>
<li>SUM 函数：计算总和<br>SELECT SUM(字段) FROM 表名;<blockquote>
<p>SELECT SUM(money*number) AS total<br>FROM products<br>WHERE prod_name &#x3D; ‘shangping1’;</p>
</blockquote>
</li>
<li>聚焦不同的值<br>SELECT DISTINCT 字段 FROM 表名;<blockquote>
<p>SELECT AVG(DISTINCT id) AS ans<br>FROM products<br>WHERE prod_name &#x3D; ‘shangping1’;</p>
</blockquote>
</li>
</ol>
<h1 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h1><ol>
<li>GROUP BY 语句：对数据进行分组</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name ,COUNT(*) AS ans</span><br><span class="line">FROM products</span><br><span class="line">GROUP BY prod_name;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>HAVING 语句：对分组数据进行过滤</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT prod_name ,COUNT(*) AS ans</span><br><span class="line">FROM products</span><br><span class="line">GROUP BY prod_name</span><br><span class="line">HAVING COUNT(*) &gt; 1;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>SELECT子句顺序</li>
</ol>
<table>
<thead>
<tr>
<th>子 句</th>
<th>说 明</th>
<th>是否必须使用</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT</td>
<td>要返回的列或表达式</td>
<td>是</td>
</tr>
<tr>
<td>FROM</td>
<td>从中检索数据的表</td>
<td>仅在从表选择数据时使用</td>
</tr>
<tr>
<td>WHERE</td>
<td>行级过滤</td>
<td>否</td>
</tr>
<tr>
<td>GROUP BY</td>
<td>分组说明</td>
<td>仅在按组计算聚集时使用</td>
</tr>
<tr>
<td>HAVING</td>
<td>组级过滤</td>
<td>否</td>
</tr>
<tr>
<td>ORDER BY</td>
<td>输出排序顺序</td>
<td>否</td>
</tr>
<tr>
<td>LIMIT</td>
<td>要检索的行数</td>
<td>否</td>
</tr>
</tbody></table>
<h1 id="使用子查询"><a href="#使用子查询" class="headerlink" title="使用子查询"></a>使用子查询</h1><ol>
<li>利用子查询进行过滤</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT cust_contact, cust_email</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_id IN (SELECT cust_id</span><br><span class="line">                  FROM orders</span><br><span class="line">                  WHERE order_num IN (SELECT order_num</span><br><span class="line">                                       FROM orderitems</span><br><span class="line">                                       WHERE prod_id = &#x27;P001&#x27;</span><br><span class="line"> ));</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>作为计算字段使用子查询</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   SELECT cust_name, cust_state, (SELECT COUNT(*)</span><br><span class="line">                                 FROM orders</span><br><span class="line">                                 WHERE orders.cust_id = customers.cust_id) AS orders</span><br><span class="line">FROM customers</span><br><span class="line">ORDER BY cust_name;</span><br></pre></td></tr></table></figure>

<h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><ol>
<li>等值联结</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT vend_name, prod_name, prod_price</span><br><span class="line">FROM vendors, products</span><br><span class="line">WHERE vendors.vend_id = products.vend_id</span><br><span class="line">ORDER BY vend_name, prod_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>笛卡尔积</li>
</ol>
<p>SELECT * FROM 表名1, 表名2;    笛卡尔积</p>
<blockquote>
<p>SELECT * FROM products, orderitems;</p>
<ol start="3">
<li>INNER JOIN:内联联结</li>
</ol>
</blockquote>
<p>SELECT 字段 FROM 表名1 INNER JOIN 表名2 ON 表名1.字段 &#x3D; 表名2.字段;</p>
<blockquote>
<p>SELECT vend_name, prod_name, prod_price<br>   FROM vendors INNER JOIN products<br>   ON vendors.vend_id &#x3D; products.vend_id;</p>
</blockquote>
<ol start="4">
<li>联结多个表&#x3D;&#x3D;上一章的利用子查询进行过滤</li>
</ol>
<blockquote>
<p>SELECT cust_name, cust_contact<br>   FROM customers, orders, orderitems<br>   WHERE customers.cust_id &#x3D; orders.cust_id<br>   AND orderitems.order_num &#x3D; orders.order_num<br>   AND prod_id &#x3D; ‘P001’;</p>
</blockquote>
<h1 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h1><ol>
<li>使用别名</li>
</ol>
<blockquote>
<p>SELECT cust_name, cust_contact<br>   FROM customers AS c, orders AS o, orderitems AS oi<br>   WHERE c.cust_id &#x3D; o.cust_id<br>   AND oi.order_num &#x3D; o.order_num<br>   AND prod_id &#x3D; ‘P001’;</p>
</blockquote>
<ol start="2">
<li>自联结</li>
</ol>
<blockquote>
<p>SELECT p1.prod_id, p1.prod_name<br>   FROM products AS p1, products AS p2<br>   WHERE p1.vend_id &#x3D; p2.vend_id<br>   AND p2.prod_id &#x3D; ‘P001’;</p>
</blockquote>
<ol start="3">
<li>自然联结：结果会将相同的列不显示</li>
</ol>
<blockquote>
<p>SELECT c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, oi.item_price<br>   FROM customers AS c, orders AS o, orderitems AS oi<br>   WHERE c.cust_id &#x3D; o.cust_id<br>  AND oi.order_num &#x3D; o.order_num<br>  AND oi.prod_id &#x3D; ‘P001’;</p>
</blockquote>
<ol start="4">
<li><p>外部联结：结果会显示所有行，包括联结条件为空的行,而内部联结仅仅显示满足条件的行</p>
<ol>
<li>LEFT OUTER JOIN</li>
<li>RIGHT OUTER JOIN</li>
</ol>
</li>
<li><p>示例：使用带聚函数的联结</p>
<blockquote>
<p>SELECT customers.cust_name, customers.cust_id, COUNT(orders.order_num) AS num_ord<br>FROM customers<br>INNER JOIN orders<br>ON customers.cust_id &#x3D; orders.cust_id<br>GROUP BY customers.cust_id;</p>
</blockquote>
</li>
</ol>
<h1 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h1><ol>
<li>UNION：合并两或多个查询结果</li>
</ol>
<blockquote>
<p> SELECT vend_id, prod_id, prod_price<br>   FROM products<br>   WHERE prod_price &lt;&#x3D; 250.0<br>   UNION<br>   SELECT vend_id, prod_id, prod_price<br>   FROM products<br>   WHERE vend_id IN (‘V001’, ‘V003’);</p>
</blockquote>
<ol start="2">
<li>UNION ALL：合并两或多个查询结果，并保留重复行</li>
</ol>
<blockquote>
<p>SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE prod_price &lt;&#x3D; 250.0<br>UNION ALL<br>SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE vend_id IN (‘V001’, ‘V003’);</p>
</blockquote>
<ol start="3">
<li>排序只需要在最后一条语句中添加 ORDER BY 语句<blockquote>
<p>SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE prod_price &lt;&#x3D; 250.0<br>UNION<br>SELECT vend_id, prod_id, prod_price<br>FROM products<br>WHERE vend_id IN (‘V001’, ‘V003’)<br>ORDER BY prod_price;</p>
</blockquote>
</li>
</ol>
<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><ol>
<li>插入整行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">INSERT INTO vendors (</span><br><span class="line">    vend_id,</span><br><span class="line">    vend_name,</span><br><span class="line">    vend_address,</span><br><span class="line">    vend_city,</span><br><span class="line">    vend_state,</span><br><span class="line">    vend_zip,</span><br><span class="line">    vend_country) </span><br><span class="line">VALUES (</span><br><span class="line">    &#x27;V011&#x27;,</span><br><span class="line">    &#x27;供应商十一&#x27;,</span><br><span class="line">    &#x27;郑州市龙子湖区四七街道00号&#x27;,</span><br><span class="line">    &#x27;郑州市&#x27;,</span><br><span class="line">    &#x27;河南&#x27;,</span><br><span class="line">    &#x27;543112&#x27;,</span><br><span class="line">    &#x27;china&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>插入多行</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">INSERT INTO vendors (</span><br><span class="line">    vend_id,</span><br><span class="line">    vend_name,</span><br><span class="line">    vend_address,</span><br><span class="line">    vend_city,</span><br><span class="line">    vend_state,</span><br><span class="line">    vend_zip,</span><br><span class="line">    vend_country) </span><br><span class="line">VALUES (</span><br><span class="line">    &#x27;V011&#x27;,</span><br><span class="line">    &#x27;供应商十一&#x27;,</span><br><span class="line">    &#x27;郑州市龙子湖区四七街道00号&#x27;,</span><br><span class="line">    &#x27;郑州市&#x27;,</span><br><span class="line">    &#x27;河南&#x27;,</span><br><span class="line">    &#x27;543112&#x27;,</span><br><span class="line">    &#x27;china&#x27;</span><br><span class="line">),</span><br><span class="line">(&#x27;V012&#x27;,</span><br><span class="line">    &#x27;供应商十二&#x27;,</span><br><span class="line">    &#x27;郑州市龙子湖区四七街道01号&#x27;,</span><br><span class="line">    &#x27;郑州市&#x27;,</span><br><span class="line">    &#x27;河南&#x27;,</span><br><span class="line">    &#x27;5431134&#x27;,</span><br><span class="line">    &#x27;china&#x27;);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>插入检索出的数据（行数要对应）</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">INSERT INTO example (a1, A2, A3, A4, A5, A6, A7, A8, A9)</span><br><span class="line">SELECT *</span><br><span class="line">FROM customers;</span><br></pre></td></tr></table></figure>

<h1 id="更新和删除数据"><a href="#更新和删除数据" class="headerlink" title="更新和删除数据"></a>更新和删除数据</h1><ol>
<li>更新数据（没有过滤就是更新所有cust_email字段）</li>
</ol>
<blockquote>
<p>UPDATE customers<br>SET cust_email &#x3D; ‘<a href="mailto:&#110;&#x65;&#x77;&#x65;&#x6d;&#97;&#105;&#x6c;&#64;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#109;">newemail@example.com</a>‘<br>WHERE cust_id &#x3D; ‘1000000001’;</p>
</blockquote>
<ol start="2">
<li>删除数据(没有过滤的话就是删除所有)</li>
</ol>
<blockquote>
<p> DELETE FROM customers<br>WHERE cust_id &#x3D; ‘1000000001’;</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>操作系统真相还原</title>
    <url>/uncategorized/%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9C%9F%E7%9B%B8%E8%BF%98%E5%8E%9F/</url>
    <content><![CDATA[<h2 id="零章"><a href="#零章" class="headerlink" title="零章"></a>零章</h2><ul>
<li>内存中为什么要分段，操作系统真相还原说不分段无法让不同的程序同时访问相同的物理内存，但是给我虚拟地址最后还是回到了一样的物理内存啊<ul>
<li>“分段避免直接用物理地址，通过段基址+偏移量，让多个进程并发运行，逻辑地址映射不同物理地址，实现隔离。”</li>
<li>“分段因大小不固定产生碎片，分页用固定页面优化内存管理。”</li>
<li>例子：段基址0x1000+偏移0x100=物理0x1100，分段隔离进程</li>
</ul>
</li>
<li>编译性语言与解释性语言<ul>
<li>编译型 <ul>
<li>过程：<br>  预处理：处理头文件、宏（#include展开）。<br>  编译：源代码（C/C++）一次性翻译成汇编代码（.s文件，比如mov eax, 1）。<br>  汇编：汇编器（as/nasm）把汇编代码转成机器码（目标文件，.o）。<br>  链接：链接器（ld）把多个目标文件和库合成可执行文件（.exe）。<br>  运行时，OS加载机器码，CPU直接执行</li>
</ul>
</li>
<li>解释型<ul>
<li>过程<br>  解释器逐行读取源代码。<br>  每行直接翻译成机器码（或中间表示后转机器码），交给CPU执行。<br>  不生成独立文件，下行接着译。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><ol>
<li>为什么内存条大小不能超过地址总线的访问范围<ol>
<li>因为地址总线的宽度是硬件设计上的限制，超出地址总线的访问范围，cpu就无法生成地址去访问他了</li>
<li>那么为什么还有TB的内存，64位操作系统理论内存条最大为16EB</li>
<li>地址是地址总线的输出</li>
</ol>
</li>
<li>为什么实模式下段基址要左移4位<ol>
<li>首先实模式是没有内存保护，线程隔离的电脑重启或开机的状态（BIOS之后的默认状态）</li>
<li>由于历史原因，以前的是20位地址总线—1MB，现在都是32位地址总线—4GB</li>
</ol>
</li>
<li>ROM:只读存储器</li>
</ol>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><ol>
<li>编译器给程序中各符号（变量名或函数名等）分配的地址，就是各符号相对于文件开头的偏移量。</li>
<li>实模式<ol>
<li>sp,bp,ss寄存器关系：ss寄存器是段寄存器提供段基址，sp,bp提供偏移量，sp指向栈顶，bp指向没有局部变量的栈顶(不包括函数，参数)</li>
</ol>
</li>
<li>简单汇编命令<ol>
<li>call<br>16 位实模式相对近调用 — 操作数==目标地址-当前地址-指令长度，不跨段<br>16 位实模式间接绝对近调用  — 地址在内存或寄存器，是绝对地址，不跨段<br>16 位实模式直接绝对远调用  —地址为立即数直接用，是绝对地址，跨段<br>16 位实模式间接绝对远调用  — 地址在内存，是绝对地址，跨段</li>
<li>jmp<br>16 位实模式相对短转移 操作数==目标地址-当前地址-指令长度，不跨段,-128-127,一字节<br>16 位实模式相对近转移 同上，2字节<br>16 位实模式间接绝对近转移 具体同call<br>16 位实模式直接绝对远转移 具体同call<br>16 位实模式间接绝对远转移 具体同call</li>
<li>jxx<br>a 表示 above 大于<br>b 表示 below 小于<br>c 表示 carry 进位<br>e 表示 equal 等于<br>g 表示 great 大于<br>j 表示 jmp 跳转<br>l 表示 less 小于<br>n 表示 not 非<br>o 表示 overflow 溢出<br>p 表示 parity 奇偶</li>
</ol>
</li>
</ol>
<h2 id="前三章小结"><a href="#前三章小结" class="headerlink" title="前三章小结"></a>前三章小结</h2><p>电脑开机之后，根据cpu复位时被硬件初始化的固定值（0xFFFF0），cpu找到实模式下BIOS的入口地址，就在1M内存的oxFFF0(大概16B大小)处，这里是一个跳转指令，跳转到真正的BIOS代码区，然后BIOS太小，只负责基本初始化，完不成所有任务，会将控制权交给MBR（主引导程序）,MBR（在磁盘第零扇区，或者第一，看命名方法）会被放在实模式下的可用空间0x7c00(为什么是这里，历史问题)，然后在这里加载，再然后会加控制权移交给加载器等</p>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="解惑区"><a href="#解惑区" class="headerlink" title="解惑区"></a>解惑区</h3><ol>
<li>保护模式段寄存器为什么还是16位？<ol>
<li>兼容实模式:8086</li>
<li>保护模式存选择子：13位索引（一位区分GDT/LDT，一位区分特权级别）GDT/LDT（8192项），够用<ol>
<li>实模式：基址 = 段 × 16 + 偏移。</li>
<li>保护模式：基址从描述符取 + 偏移。</li>
</ol>
</li>
</ol>
</li>
<li>bits 伪指令用于指定运行模式，操作数大小反转前缀 0x66 和寻址方式反转前缀 0x67，用于临时将当前运行模式下的操作数大小和寻址方式转变成另外一种模式下的操作数大小及寻址方式</li>
<li>段描述符记录了段基址，段界限，那么偏移量在哪<ol>
<li>偏移量：指令操作数提供，通常在通用寄存器（如ebx）或立即数。</li>
</ol>
</li>
</ol>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="疑惑区"><a href="#疑惑区" class="headerlink" title="疑惑区"></a>疑惑区</h3><ol>
<li>为什么页表中只有20位是存放物理地址的<br>1.因为页目录项和页表项中的都是物理页地址，标准页大小是 4KB，故地址都是 4K 的倍数，也就是地址的低 12位是 0，所以只需要记录物理地址高 20 位就可以</li>
<li>CPL与DPL<ol>
<li>CPL：当前特权级（CS低2位）</li>
<li>DPL：描述符特权级（GDT中）。<br>规则：CPL ≤ DPL可访问。</li>
</ol>
</li>
<li>高特权为何禁低特权代码：<br>CPL &lt; DPL禁止，防内核跑用户恶意代码,中断/门例外。</li>
<li>一致性代码：<br>CPL ≤ DPL可访问，CPL不变</li>
<li>将gcc降级<a href="https://blog.csdn.net/weixin_42640948/article/details/123030522">https://blog.csdn.net/weixin_42640948/article/details/123030522</a></li>
<li>为什么页表创建后我们的低1MB与物理地址是一一对应的关系<br>7.早已经采用了平坦模型，为什么所有用户进程共享几个选择子</li>
</ol>
<h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><ol>
<li>特权级—-内核态（CPL=0） 运行时，GS 可能指向 DPL=0 的显存段描述符（比如 0xB8000）。<br>返回用户态（CPL=3） 时：<br>如果 GS 仍然指向 DPL=0 的显存段，如果没有检查措施的情况下，用户太是不可以访问GS的吧，因为max(CPL,RPL)&gt;DPL(0),没有检查的话，是将问题延后了，只是用户态不可能有机会访问它</li>
</ol>
<h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><ol>
<li>什么是开中断，什么是关中断</li>
<li>介绍一下#ifdef —#else  #endif结构</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> 宏名</span></span><br><span class="line">    <span class="comment">// 如果 宏名 被定义，则编译这部分代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 如果 宏名 没有被定义，则编译这部分代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><ol>
<li>进程与线程的区别<ol>
<li>进程=线程+资源</li>
<li>进程分为单线程进程（只有一个执行流即一个线程）与多线程进程（多个执行流，即多个线程）</li>
<li>进程占有全部资源，线程要依赖与进程的资源，线程之间的资源可相互读、写</li>
<li>线程可以看为将进程的一些函数拉出来单独执行</li>
</ol>
</li>
<li>关中断如何实现原子性<ol>
<li>就是说关中断使得不会被硬件设备中断，这是哪怕是处理器告诉你：哥们你的执行时间到了，该下去了，这时候也不会被中断</li>
<li>GPT：关中断（CLI 指令）会禁止所有外部硬件中断，即使是处理器的调度机制本身也无法强行打断你的执行</li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>tcp_ip网络编程</title>
    <url>/uncategorized/%E7%AC%94%E8%AE%B0/tcp_ip%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/note/</url>
    <content><![CDATA[<h1 id="第1章"><a href="#第1章" class="headerlink" title="第1章"></a>第1章</h1><h2 id="服务器套接字创建"><a href="#服务器套接字创建" class="headerlink" title="服务器套接字创建"></a>服务器套接字创建</h2><ol>
<li><code>socket()</code>：创建套接字。</li>
<li><code>bind()</code>：将服务器的 IP 地址和端口号绑定到一个套接字上。<ol>
<li>INADDR_ANY:指定地址0.0.0.0，以为这台机器的任意数据（是向绑定的端口号发送的）都可接收</li>
</ol>
</li>
<li><code>listen()</code>：设为监听状态</li>
<li><code>accept()</code>：接受连接请求。</li>
</ol>
<h2 id="客户端步骤"><a href="#客户端步骤" class="headerlink" title="客户端步骤"></a>客户端步骤</h2><ol>
<li><code>socket()</code>：创建套接字。</li>
<li><code>connect()</code>：向服务器发连接请求。</li>
</ol>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><div class="table-container">
<table>
<thead>
<tr>
<th>描述符</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>标准输入</td>
</tr>
<tr>
<td>1</td>
<td>标准输出</td>
</tr>
<tr>
<td>2</td>
<td>标准错误</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>文件和套接字创建后分配描述符。</li>
<li>Linux用“描述符”，Windows用“句柄”。</li>
</ul>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul>
<li><strong>打开</strong>：<code>int open(const char *path, int flag)</code><ul>
<li>返回：描述符（成功），-1（失败）。</li>
<li><strong>flag</strong>：<ul>
<li><code>O_CREAT</code>：创建文件。</li>
<li><code>O_TRUNC</code>：清空数据。</li>
<li><code>O_APPEND</code>：追加数据。</li>
<li><code>O_RDONLY</code>：只读。</li>
<li><code>O_WRONLY</code>：只写。</li>
<li><code>O_RDWR</code>：读写。</li>
</ul>
</li>
</ul>
</li>
<li><strong>关闭</strong>：<code>int close(int fd)</code><ul>
<li>返回：0（成功），-1（失败）。</li>
</ul>
</li>
<li><strong>写</strong>：<code>ssize_t write(int fd, const void *buf, size_t nbytes)</code><ul>
<li>返回：写入字节数（成功），-1（失败）。</li>
</ul>
</li>
<li><strong>读</strong>：<code>ssize_t read(int fd, void *buf, size_t nbytes)</code><ul>
<li>返回：读取字节数（成功），0（文件末尾），-1（失败）。</li>
</ul>
</li>
</ul>
<h1 id="第2章"><a href="#第2章" class="headerlink" title="第2章"></a>第2章</h1><h2 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h2><ul>
<li><strong>函数</strong>: <code>int socket(int domain, int type, int protocol)</code><ul>
<li>返回: 文件描述符（成功），-1（失败）</li>
<li><strong>domain</strong>: 协议族</li>
<li><strong>type</strong>: 传输方式</li>
<li><strong>protocol</strong>: 具体协议</li>
</ul>
</li>
</ul>
<h2 id="协议族"><a href="#协议族" class="headerlink" title="协议族"></a>协议族</h2><ul>
<li><strong>PF_INET</strong>: IPv4，常用</li>
<li>其他（PF_INET6、PF_LOCAL）略</li>
</ul>
<h2 id="套接字类型"><a href="#套接字类型" class="headerlink" title="套接字类型"></a>套接字类型</h2><ol>
<li><strong>SOCK_STREAM</strong>（面向连接，TCP）<ul>
<li>可靠、按序、无边界</li>
<li>有缓冲，慢但不丢数据</li>
</ul>
</li>
<li><strong>SOCK_DGRAM</strong>（面向消息，UDP）<ul>
<li>快、不可靠、有边界</li>
<li>可能丢包</li>
</ul>
</li>
</ol>
<h2 id="协议选择"><a href="#协议选择" class="headerlink" title="协议选择"></a>协议选择</h2><ul>
<li><strong>TCP</strong>: <code>socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)</code></li>
<li><strong>UDP</strong>: <code>socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)</code></li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// TCP套接字</span></span><br><span class="line"><span class="type">int</span> tcp = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"><span class="comment">// UDP套接字</span></span><br><span class="line"><span class="type">int</span> udp = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br></pre></td></tr></table></figure>
<h1 id="第3章地址族与数据序列"><a href="#第3章地址族与数据序列" class="headerlink" title="第3章地址族与数据序列"></a>第3章地址族与数据序列</h1><h2 id="表示-IPV4-地址的结构体"><a href="#表示-IPV4-地址的结构体" class="headerlink" title="表示 IPV4 地址的结构体"></a>表示 IPV4 地址的结构体</h2><p>通用的地址结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sa_family;   <span class="comment">// 地址族，例如 AF_INET、AF_INET6</span></span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>];           <span class="comment">// 存储套接字地址的数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>IPV4 地址结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sin_family;  <span class="comment">//地址族（Address Family）</span></span><br><span class="line">    <span class="type">uint16_t</span> sin_port;       <span class="comment">//16 位 TCP/UDP 端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">//32位 IP 地址</span></span><br><span class="line">    <span class="type">char</span> sin_zero[<span class="number">8</span>];        <span class="comment">//不使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体中提到的另一个结构体 in_addr 定义如下，它用来存放 32 位IP地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">in_addr_t</span> s_addr; <span class="comment">//32位IPV4地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于以上两个结构体的一些数据类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">数据类型名称</th>
<th style="text-align:center">数据类型说明</th>
<th style="text-align:center">声明的头文件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int 8_t</td>
<td style="text-align:center">signed 8-bit int</td>
<td style="text-align:center">sys/types.h</td>
</tr>
<tr>
<td style="text-align:center">uint8_t</td>
<td style="text-align:center">unsigned 8-bit int (unsigned char)</td>
<td style="text-align:center">sys/types.h</td>
</tr>
<tr>
<td style="text-align:center">int16_t</td>
<td style="text-align:center">signed 16-bit int</td>
<td style="text-align:center">sys/types.h</td>
</tr>
<tr>
<td style="text-align:center">uint16_t</td>
<td style="text-align:center">unsigned 16-bit int (unsigned short)</td>
<td style="text-align:center">sys/types.h</td>
</tr>
<tr>
<td style="text-align:center">int32_t</td>
<td style="text-align:center">signed 32-bit int</td>
<td style="text-align:center">sys/types.h</td>
</tr>
<tr>
<td style="text-align:center">uint32_t</td>
<td style="text-align:center">unsigned 32-bit int (unsigned long)</td>
<td style="text-align:center">sys/types.h</td>
</tr>
<tr>
<td style="text-align:center">sa_family_t</td>
<td style="text-align:center">地址族（address family）</td>
<td style="text-align:center">sys/socket.h</td>
</tr>
<tr>
<td style="text-align:center">socklen_t</td>
<td style="text-align:center">长度（length of struct）</td>
<td style="text-align:center">sys/socket.h</td>
</tr>
<tr>
<td style="text-align:center">in_addr_t</td>
<td style="text-align:center">IP地址，声明为 uint_32_t</td>
<td style="text-align:center">netinet/in.h</td>
</tr>
<tr>
<td style="text-align:center">in_port_t</td>
<td style="text-align:center">端口号，声明为 uint_16_t</td>
<td style="text-align:center">netinet/in.h</td>
</tr>
</tbody>
</table>
</div>
<p>为什么要额外定义这些数据类型呢？<br>以后的64位，或者更多位，都可以保证确定的字节数</p>
<h2 id="结构体-sockaddr-in-的成员分析"><a href="#结构体-sockaddr-in-的成员分析" class="headerlink" title="结构体 sockaddr_in 的成员分析"></a>结构体 sockaddr_in 的成员分析</h2><ul>
<li>成员 sin_family</li>
</ul>
<blockquote>
<p>地址族</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>地址族（Address Family）</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>AF_INET</td>
<td>IPV4用的地址族</td>
</tr>
<tr>
<td>AF_INET6</td>
<td>IPV6用的地址族</td>
</tr>
<tr>
<td>AF_LOCAL</td>
<td>本地通信中采用的 Unix 协议的地址族</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>成员 sin_port</p>
<p>该成员保存 16 位端口号，重点在于，它以网络字节序保存。</p>
</li>
<li><p>成员 sin_addr</p>
<p>该成员保存 32 位 IP 地址信息，且也以网络字节序保存</p>
</li>
<li><p>成员 sin_zero</p>
<p>无特殊含义。</p>
</li>
</ul>
<h2 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h2><p>帮助转换字节序的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">htons</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span>)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">htonl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>htons 的 h 代表主机（host）字节序。</li>
<li>htons 的 n 代表网络（network）字节序。</li>
<li>s 代表两个字节的 short 类型，因此以 s 为后缀的函数用于端口转换</li>
<li>l 代表四个字节的 long 类型，所以以 l 为后缀的函数用于 IP 地址转换</li>
</ul>
<h2 id="将字符串信息转换为网络字节序的整数型"><a href="#将字符串信息转换为网络字节序的整数型" class="headerlink" title="将字符串信息转换为网络字节序的整数型"></a>将字符串信息转换为网络字节序的整数型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br><span class="line"><span class="comment">//成功时返回 32 位大端序整数型值，失败时返回 INADDR_NONE</span></span><br></pre></td></tr></table></figure>
<p>inet_aton 函数与 inet_addr 函数在功能上完全相同，也是将字符串形式的IP地址转换成整数型的IP地址。只不过该函数用了 in_addr 结构体，且使用频率更高。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>, <span class="keyword">struct</span> in_addr *addr)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 1 ，失败时返回 0</span></span><br><span class="line"><span class="comment">string: 含有需要转换的IP地址信息的字符串地址值</span></span><br><span class="line"><span class="comment">addr: 保存转换结果的 in_addr 结构体变量的地址值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>还有一个函数，与 inet_aton() 正好相反，它可以把网络字节序整数型IP地址转换成我们熟悉的字符串形式，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr adr)</span>;</span><br><span class="line"><span class="comment">//成功时返回保存转换结果的字符串地址值，失败时返回 NULL 空指针</span></span><br></pre></td></tr></table></figure>
<p>该函数会自己分配空间存储结果，多次调用的结果在一个位置，需另外保存结果否则会被覆盖</p>
<h1 id="第四章-基于TCP的服务器-客户端"><a href="#第四章-基于TCP的服务器-客户端" class="headerlink" title="第四章 基于TCP的服务器/客户端"></a>第四章 基于TCP的服务器/客户端</h1><h2 id="回声服务器—echo-sever-c"><a href="#回声服务器—echo-sever-c" class="headerlink" title="回声服务器—echo_sever.c"></a>回声服务器—echo_sever.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len, i;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">    <span class="comment">//调用 5 次 accept 函数，共为 5 个客户端提供服务</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        clnt_sock = accept(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">        <span class="keyword">if</span> (clnt_sock == <span class="number">-1</span>)</span><br><span class="line">            error_handling(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Connect client %d \n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> ((str_len = read(clnt_sock, message, BUF_SIZE)) != <span class="number">0</span>)</span><br><span class="line">            write(clnt_sock, message, str_len);</span><br><span class="line"></span><br><span class="line">        close(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="回声客户端—echo-client-c"><a href="#回声客户端—echo-client-c" class="headerlink" title="回声客户端—echo_client.c"></a>回声客户端—echo_client.c</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len,recv_len,recv_cnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connected...........&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input message(Q to quit): &quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        fgets(message, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        str_len=write(sock, message, <span class="built_in">strlen</span>(message));</span><br><span class="line">        <span class="keyword">while</span>(recv_len&lt;str_len)</span><br><span class="line">        &#123;</span><br><span class="line">            recv_cnt=read(sock,&amp;message[recv_len<span class="number">-1</span>],BUF_SIZE<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(recv_cnt==<span class="number">-1</span>)</span><br><span class="line">                error_handling(<span class="string">&quot;read() error&quot;</span>);</span><br><span class="line">            recv_len+=recv_cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        message[str_len] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第五章-基于TCP的服务器-客户端"><a href="#第五章-基于TCP的服务器-客户端" class="headerlink" title="第五章 基于TCP的服务器/客户端"></a>第五章 基于TCP的服务器/客户端</h1><h2 id="计算器服务器"><a href="#计算器服务器" class="headerlink" title="计算器服务器"></a>计算器服务器</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPSZ 4</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> opnum, <span class="type">int</span> opnds[], <span class="type">char</span> oprator)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock, clnt_sock;</span><br><span class="line">    <span class="type">char</span> opinfo[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> result, opnd_cnt, i;</span><br><span class="line">    <span class="type">int</span> recv_cnt, recv_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>, <span class="title">clnt_adr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_adr_sz;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (serv_sock == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bind(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (listen(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    clnt_adr_sz = <span class="keyword">sizeof</span>(clnt_adr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        opnd_cnt = <span class="number">0</span>;</span><br><span class="line">        clnt_sock = accept(serv_sock, (<span class="keyword">struct</span> sockaddr *)&amp;clnt_adr, &amp;clnt_adr_sz);</span><br><span class="line">        read(clnt_sock, &amp;opnd_cnt, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        recv_len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((opnd_cnt * OPSZ + <span class="number">1</span>) &gt; recv_len)</span><br><span class="line">        &#123;</span><br><span class="line">            recv_cnt = read(clnt_sock, &amp;opinfo[recv_len], BUF_SIZE - <span class="number">1</span>);</span><br><span class="line">            recv_len += recv_cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        result = calculate(opnd_cnt, (<span class="type">int</span> *)opinfo, opinfo[recv_len - <span class="number">1</span>]);</span><br><span class="line">        write(clnt_sock, (<span class="type">char</span> *)&amp;result, <span class="keyword">sizeof</span>(result));</span><br><span class="line">        close(clnt_sock);</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> opnum, <span class="type">int</span> opnds[], <span class="type">char</span> op)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> result = opnds[<span class="number">0</span>], i;</span><br><span class="line">    <span class="keyword">switch</span> (op)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; opnum; i++)</span><br><span class="line">            result += opnds[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; opnum; i++)</span><br><span class="line">            result -= opnds[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; opnum; i++)</span><br><span class="line">            result *= opnds[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计算器客户端"><a href="#计算器客户端" class="headerlink" title="计算器客户端"></a>计算器客户端</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RLT_SIZE 4 <span class="comment">//字节大小数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPSZ 4</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="type">char</span> opmsg[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> result, opnd_cnt, i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_adr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sock == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;</span><br><span class="line">    serv_adr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_adr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sock, (<span class="keyword">struct</span> sockaddr *)&amp;serv_adr, <span class="keyword">sizeof</span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Connected...........&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Operand count: &quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;opnd_cnt);</span><br><span class="line">    opmsg[<span class="number">0</span>] = (<span class="type">char</span>)opnd_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; opnd_cnt; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Operand %d: &quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, (<span class="type">int</span> *)&amp;opmsg[i * OPSZ + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    fgetc(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Operator: &quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;opmsg[opnd_cnt * OPSZ + <span class="number">1</span>]);</span><br><span class="line">    write(sock, opmsg, opnd_cnt * OPSZ + <span class="number">2</span>);</span><br><span class="line">    read(sock, &amp;result, RLT_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Operation result: %d \n&quot;</span>, result);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第六章-基于UDP的服务器-客户端"><a href="#第六章-基于UDP的服务器-客户端" class="headerlink" title="第六章 基于UDP的服务器/客户端"></a>第六章 基于UDP的服务器/客户端</h1><h2 id="基于-UDP-的数据-I-O-函数"><a href="#基于-UDP-的数据-I-O-函数" class="headerlink" title="基于 UDP 的数据 I/O 函数"></a>基于 UDP 的数据 I/O 函数</h2><h3 id="发送信息"><a href="#发送信息" class="headerlink" title="发送信息"></a>发送信息</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sock, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">               <span class="keyword">struct</span> sockaddr *to, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回发送的字节数，失败时返回 -1</span></span><br><span class="line"><span class="comment">sock: 用于传输数据的 UDP 套接字</span></span><br><span class="line"><span class="comment">buff: 保存待传输数据的缓冲地址值</span></span><br><span class="line"><span class="comment">nbytes: 待传输的数据长度，以字节为单位</span></span><br><span class="line"><span class="comment">flags: 可选项参数，若没有则传递 0</span></span><br><span class="line"><span class="comment">to: 存有目标地址的 sockaddr 结构体变量的地址值</span></span><br><span class="line"><span class="comment">addrlen: 传递给参数 to 的地址值结构体变量长度</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="接受信息"><a href="#接受信息" class="headerlink" title="接受信息"></a>接受信息</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sock, <span class="type">void</span> *buff, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> sockaddr *from, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回接收的字节数，失败时返回 -1</span></span><br><span class="line"><span class="comment">sock: 用于传输数据的 UDP 套接字</span></span><br><span class="line"><span class="comment">buff: 保存待传输数据的缓冲地址值</span></span><br><span class="line"><span class="comment">nbytes: 待传输的数据长度，以字节为单位</span></span><br><span class="line"><span class="comment">flags: 可选项参数，若没有则传递 0</span></span><br><span class="line"><span class="comment">from: 存有发送端地址信息的 sockaddr 结构体变量的地址值</span></span><br><span class="line"><span class="comment">addrlen: 保存参数 from 的结构体变量长度的变量地址值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p> 如果调用 sendto 函数尚未分配地址信息，则在首次调用 sendto 函数时给相应套接字自动分配 IP 和端口。而且此时分配的地址一直保留到程序结束为止</p>
<h2 id="UDP-服务器端程序"><a href="#UDP-服务器端程序" class="headerlink" title="UDP 服务器端程序"></a>UDP 服务器端程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE=<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock,str_len;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_addr_size;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock=socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);<span class="comment">//为什么使用的是htonl而不是inet_aton--使用INADDR_ANY，表示使用的是主机的IP地址，直接转换为网络即可，inet_aton适用于字符长转为网络序列</span></span><br><span class="line">    serv_addr.sin_port=htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(sock,(<span class="keyword">struct</span> sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        clnt_addr_size=<span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">        str_len=recvfrom(sock,message,BUF_SIZE,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;clnt_addr,&amp;clnt_addr_size);</span><br><span class="line">        sendto(sock,message,BUF_SIZE,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;clnt_addr,clnt_addr_size);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="UDP-客户端程序"><a href="#UDP-客户端程序" class="headerlink" title="UDP 客户端程序"></a>UDP 客户端程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE=<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">from_addr</span>;</span></span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line">    <span class="type">socklen_t</span> addr_size;</span><br><span class="line"></span><br><span class="line">    sock=socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Insert message(q to quit): &quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">        fgets(message,<span class="keyword">sizeof</span>(message),<span class="built_in">stdin</span>);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(message,<span class="string">&quot;q\n&quot;</span>)|| !<span class="built_in">strcmp</span>(message,<span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        sendto(sock,message,BUF_SIZE,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">        addr_size=<span class="keyword">sizeof</span>(from_addr);</span><br><span class="line">        str_len=recvfrom(sock,message,BUF_SIZE,<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;from_addr,&amp;addr_size);</span><br><span class="line">        message[str_len]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>,message);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第7章-优雅的断开套接字的连接"><a href="#第7章-优雅的断开套接字的连接" class="headerlink" title="第7章 优雅的断开套接字的连接"></a>第7章 优雅的断开套接字的连接</h1><h2 id="针对优雅断开的-shutdown-函数"><a href="#针对优雅断开的-shutdown-函数" class="headerlink" title="针对优雅断开的 shutdown 函数"></a>针对优雅断开的 shutdown 函数</h2><p>shutdown 用来关闭其中一个流：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> howto)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">sock: 需要断开套接字文件描述符</span></span><br><span class="line"><span class="comment">howto: 传递断开方式信息</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>调用上述函数时，第二个参数决定断开连接的方式，其值如下所示：</p>
<ul>
<li><code>SHUT_RD</code> : 断开输入流</li>
<li><code>SHUT_WR</code> : 断开输出流</li>
<li><code>SHUT_RDWR</code> : 同时断开 I/O 流</li>
</ul>
<h2 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE=<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handling_error</span><span class="params">(<span class="type">char</span>* message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock,clnt_sock;</span><br><span class="line">    <span class="type">int</span> read_cnt;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_addr_len;</span><br><span class="line">    FILE *file;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    file=fopen(<span class="string">&quot;file_server.c&quot;</span>,<span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    serv_sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_sock==<span class="number">-1</span>)handling_error(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port=htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(serv_sock,(<span class="keyword">struct</span> sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">        handling_error(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(listen(serv_sock,<span class="number">5</span>)==<span class="number">-1</span>)handling_error(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clnt_addr_len=<span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">    clnt_sock=accept(serv_sock,(<span class="keyword">struct</span> sockaddr*)&amp;clnt_addr,&amp;clnt_addr_len);</span><br><span class="line">    <span class="keyword">if</span>(clnt_sock==<span class="number">-1</span>)</span><br><span class="line">        handling_error(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        read_cnt=fread((<span class="type">void</span>*)message,<span class="number">1</span>,BUF_SIZE,file);</span><br><span class="line">        <span class="keyword">if</span>(read_cnt&lt;BUF_SIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            write(clnt_sock,message,read_cnt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        write(clnt_sock,message,BUF_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shutdown(clnt_sock,SHUT_WR);</span><br><span class="line">    read(clnt_sock,message,BUF_SIZE);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from client: %s \n&quot;</span>,message);</span><br><span class="line"></span><br><span class="line">    fclose(file);</span><br><span class="line">    close(clnt_sock);</span><br><span class="line">    close(serv_sock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handling_error</span><span class="params">(<span class="type">char</span>* message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> BUF_SIZE=<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handling_error</span><span class="params">(<span class="type">char</span>* message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    FILE *file;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="type">int</span> read_cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file=fopen(<span class="string">&quot;receive.dat&quot;</span>,<span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(file==<span class="literal">NULL</span>)handling_error(<span class="string">&quot;fopen() error&quot;</span>);</span><br><span class="line">    sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock==<span class="number">-1</span>)handling_error(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sock,(<span class="keyword">struct</span> sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)handling_error(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(read_cnt=read(sock,message,BUF_SIZE)!=<span class="number">0</span>)</span><br><span class="line">        fwrite((<span class="type">void</span>*)message,<span class="number">1</span>,read_cnt,file);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Received file date&quot;</span>);</span><br><span class="line">    write(sock,<span class="string">&quot;Thank you&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    fclose(file);</span><br><span class="line">    close(sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handling_error</span><span class="params">(<span class="type">char</span>* message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第-8-章-域名及网络地址"><a href="#第-8-章-域名及网络地址" class="headerlink" title="第 8 章 域名及网络地址"></a>第 8 章 域名及网络地址</h1><h2 id="利用域名获取IP地址"><a href="#利用域名获取IP地址" class="headerlink" title="利用域名获取IP地址"></a>利用域名获取IP地址</h2><p>使用以下函数可以通过传递字符串格式的域名获取IP地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *hostname)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 hostent 结构体地址，失败时返回 NULL 指针</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>这个函数使用方便，只要传递字符串，就可以返回域名对应的IP地址。只是返回时，地址信息装入 hostent 结构体。此结构体的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> *h_name;       <span class="comment">/* Official name of host.  */</span></span><br><span class="line">    <span class="type">char</span> **h_aliases;   <span class="comment">/* Alias list.  */</span></span><br><span class="line">    <span class="type">int</span> h_addrtype;     <span class="comment">/* Host address type.  */</span></span><br><span class="line">    <span class="type">int</span> h_length;       <span class="comment">/* Length of address.  */</span></span><br><span class="line">    <span class="type">char</span> **h_addr_list; <span class="comment">/* List of addresses from name server.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>简要说明上述结构体的成员：</p>
<ul>
<li>h_name：该变量中存有官方域名</li>
<li>h_aliases：可以通过多个域名访问同一主页</li>
<li>h_addrtype：gethostbyname 函数不仅支持 IPV4 还支持 IPV6 </li>
<li>h_length：保存IP地址长度</li>
<li>h_addr_list：通过此变量以整数形式保存域名相对应的IP地址。另外，用户比较多的网站有可能分配多个IP地址给同一个域名，利用多个服务器做负载均衡</li>
</ul>
<h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    addr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    host = gethostbyaddr((<span class="type">char</span> *)&amp;addr.sin_addr, <span class="number">4</span>, AF_INET);</span><br><span class="line">    <span class="keyword">if</span> (!host)</span><br><span class="line">        error_handling(<span class="string">&quot;gethost... error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Official name: %s \n&quot;</span>, host-&gt;h_name);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; host-&gt;h_aliases[i]; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Aliases %d:%s \n&quot;</span>, i + <span class="number">1</span>, host-&gt;h_aliases[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address type: %s \n&quot;</span>,</span><br><span class="line">           (host-&gt;h_addrtype == AF_INET) ? <span class="string">&quot;AF_INET&quot;</span> : <span class="string">&quot;AF_INET6&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; host-&gt;h_addr_list[i]; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP addr %d: %s \n&quot;</span>, i + <span class="number">1</span>,</span><br><span class="line">               inet_ntoa(*(<span class="keyword">struct</span> in_addr *)host-&gt;h_addr_list[i]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用IP地址获取域名"><a href="#利用IP地址获取域名" class="headerlink" title="利用IP地址获取域名"></a>利用IP地址获取域名</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> hostent *<span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *addr, <span class="type">socklen_t</span> len, <span class="type">int</span> family)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 hostent 结构体变量地址值，失败时返回 NULL 指针</span></span><br><span class="line"><span class="comment">addr: 含有IP地址信息的 in_addr 结构体指针。为了同时传递 IPV4 地址之外的全部信息，该变量的类型声明为 char 指针</span></span><br><span class="line"><span class="comment">len: 向第一个参数传递的地址信息的字节数，IPV4时为 4 ，IPV6 时为16.</span></span><br><span class="line"><span class="comment">family: 传递地址族信息，ipv4 是 AF_INET ，IPV6是 AF_INET6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handling_error</span><span class="params">(<span class="type">char</span>* message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">host</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    host=gethostbyname(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(!host)</span><br><span class="line">        handling_error(<span class="string">&quot;gethostbyname() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Official name :%s \n&quot;</span>,host-&gt;h_name);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;host-&gt;h_aliases[i];i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Aliases %d : %s \n&quot;</span>,i+<span class="number">1</span>,host-&gt;h_aliases[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Address type :%s\n&quot;</span>,</span><br><span class="line">    (host-&gt;h_addrtype==AF_INET)?<span class="string">&quot;AF_INET&quot;</span>:<span class="string">&quot;AF_INETG&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;host-&gt;h_addr_list[i];i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;IP addr %d: %s \n&quot;</span>,i+<span class="number">1</span>,inet_ntoa(*(<span class="keyword">struct</span> in_addr*)host-&gt;h_addr_list[i]));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handling_error</span><span class="params">(<span class="type">char</span>* message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第-9-章-套接字的多种可选项"><a href="#第-9-章-套接字的多种可选项" class="headerlink" title="第 9 章 套接字的多种可选项"></a>第 9 章 套接字的多种可选项</h1><h2 id="套接字多种可选项"><a href="#套接字多种可选项" class="headerlink" title="套接字多种可选项"></a>套接字多种可选项</h2><p>我们之前写得程序都是创建好套接字之后直接使用的，此时通过默认的套接字特性进行数据通信，这里列出了一些套接字可选项。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">协议层</th>
<th style="text-align:center">选项名</th>
<th style="text-align:center">读取</th>
<th style="text-align:center">设置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SOL_SOCKET</td>
<td style="text-align:center">SO_SNDBUF</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">SOL_SOCKET</td>
<td style="text-align:center">SO_RCVBUF</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">SOL_SOCKET</td>
<td style="text-align:center">SO_REUSEADDR</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">SOL_SOCKET</td>
<td style="text-align:center">SO_KEEPALIVE</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">SOL_SOCKET</td>
<td style="text-align:center">SO_BROADCAST</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">SOL_SOCKET</td>
<td style="text-align:center">SO_DONTROUTE</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">SOL_SOCKET</td>
<td style="text-align:center">SO_OOBINLINE</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">SOL_SOCKET</td>
<td style="text-align:center">SO_ERROR</td>
<td style="text-align:center">O</td>
<td style="text-align:center">X</td>
</tr>
<tr>
<td style="text-align:center">SOL_SOCKET</td>
<td style="text-align:center">SO_TYPE</td>
<td style="text-align:center">O</td>
<td style="text-align:center">X</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_IP</td>
<td style="text-align:center">IP_TOS</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_IP</td>
<td style="text-align:center">IP_TTL</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_IP</td>
<td style="text-align:center">IP_MULTICAST_TTL</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_IP</td>
<td style="text-align:center">IP_MULTICAST_LOOP</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_IP</td>
<td style="text-align:center">IP_MULTICAST_IF</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_TCP</td>
<td style="text-align:center">TCP_KEEPALIVE</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_TCP</td>
<td style="text-align:center">TCP_NODELAY</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
</tr>
<tr>
<td style="text-align:center">IPPROTO_TCP</td>
<td style="text-align:center">TCP_MAXSEG</td>
<td style="text-align:center">O</td>
<td style="text-align:center">O</td>
</tr>
</tbody>
</table>
</div>
<p>从表中可以看出，套接字可选项是分层的。</p>
<ul>
<li><p>IPPROTO_IP 可选项是IP协议相关事项</p>
</li>
<li><p>IPPROTO_TCP 层可选项是 TCP 协议的相关事项</p>
</li>
<li><p>SOL_SOCKET 层是套接字的通用可选项。</p>
</li>
</ul>
<h2 id="getsockopt-amp-setsockopt"><a href="#getsockopt-amp-setsockopt" class="headerlink" title="getsockopt &amp; setsockopt"></a><code>getsockopt</code> &amp; <code>setsockopt</code></h2><p>可选项的读取和设置通过以下两个函数来完成</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">sock: 用于查看选项套接字文件描述符</span></span><br><span class="line"><span class="comment">level: 要查看的可选项协议层</span></span><br><span class="line"><span class="comment">optname: 要查看的可选项名</span></span><br><span class="line"><span class="comment">optval: 保存查看结果的缓冲地址值</span></span><br><span class="line"><span class="comment">optlen: 向第四个参数传递的缓冲大小。调用函数候，该变量中保存通过第四个参数返回的可选项信息的字节数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上述函数可以用来读取套接字可选项，下面的函数可以更改可选项：d</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sock, <span class="type">int</span> level, <span class="type">int</span> optname, <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">sock: 用于更改选项套接字文件描述符</span></span><br><span class="line"><span class="comment">level: 要更改的可选项协议层</span></span><br><span class="line"><span class="comment">optname: 要更改的可选项名</span></span><br><span class="line"><span class="comment">optval: 保存更改结果的缓冲地址值</span></span><br><span class="line"><span class="comment">optlen: 向第四个参数传递的缓冲大小。调用函数后，该变量中保存通过第四个参数返回的可选项信息的字节数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="第-10-章-多进程服务器端"><a href="#第-10-章-多进程服务器端" class="headerlink" title="第 10 章 多进程服务器端"></a>第 10 章 多进程服务器端</h1><h2 id="通过调用-fork-函数创建进程"><a href="#通过调用-fork-函数创建进程" class="headerlink" title="通过调用 fork 函数创建进程"></a>通过调用 fork 函数创建进程</h2><p>创建进程的方式很多，此处只介绍用于创建多进程服务端的 fork 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 成功时返回进程ID,失败时返回 -1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>父进程：fork 函数返回子进程 ID</li>
<li>子进程：fork 函数返回 0</li>
</ul>
<h2 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h2><blockquote>
<p>僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。如果父进程先退出 ，子进程被init接管，子进程退出后init会回收其占用的相关资源</p>
</blockquote>
<h2 id="销毁僵尸进程-1：利用-wait-函数"><a href="#销毁僵尸进程-1：利用-wait-函数" class="headerlink" title="销毁僵尸进程 1：利用 wait 函数"></a>销毁僵尸进程 1：利用 wait 函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *statloc)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回终止的子进程 ID ,失败时返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>调用此函数时如果已有子进程终止，那么子进程终止时传递的返回值（exit 函数的参数返回值，main 函数的 return 返回值）将保存到该函数的参数所指的内存空间。但函数参数指向的单元中还包含其他信息，因此需要用下列宏进行分离：</p>
<ul>
<li>WIFEXITED 子进程正常终止时返回「真」</li>
<li>WEXITSTATUS 返回子进程时的返回值</li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="type">pid_t</span> pid=fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;chlid PID :%d\n&quot;</span>,pid);</span><br><span class="line">        pid=fork();</span><br><span class="line">        <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">7</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Child PID :%d\n&quot;</span>,pid);</span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Child send one: %d \n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line">            </span><br><span class="line">            wait(&amp;status);</span><br><span class="line">            <span class="keyword">if</span>(WIFEXITED(status))</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Child send two: %d\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line">            sleep(<span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="销毁僵尸进程-2：使用-waitpid-函数"><a href="#销毁僵尸进程-2：使用-waitpid-函数" class="headerlink" title="销毁僵尸进程 2：使用 waitpid 函数"></a>销毁僵尸进程 2：使用 waitpid 函数</h2><p>wait 函数会引起程序阻塞，还可以考虑调用 waitpid 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *statloc, <span class="type">int</span> options)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回终止的子进程ID 或 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">pid: 等待终止的目标子进程的ID,若传 -1，则与 wait 函数相同，可以等待任意子进程终止</span></span><br><span class="line"><span class="comment">statloc: 与 wait 函数的 statloc 参数具有相同含义</span></span><br><span class="line"><span class="comment">options: 传递头文件 sys/wait.h 声明的常量 WNOHANG ,即使没有终止的子进程也不会进入阻塞状态，而是返回 0 退出函数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="10-3-信号处理"><a href="#10-3-信号处理" class="headerlink" title="10.3 信号处理"></a>10.3 信号处理</h2><blockquote>
<p>子进程究竟何时终止？调用 waitpid 函数后要无休止的等待吗？</p>
</blockquote>
<h2 id="信号与-signal-函数"><a href="#信号与-signal-函数" class="headerlink" title="信号与 signal 函数"></a>信号与 signal 函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> signo, <span class="type">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为了在产生信号时调用，返回之前注册的函数指针</span></span><br><span class="line"><span class="comment">函数名: signal</span></span><br><span class="line"><span class="comment">参数：int signo,void(*func)(int)</span></span><br><span class="line"><span class="comment">返回类型：参数类型为int型，返回 void 型函数指针</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>调用上述函数时，第一个参数为特殊情况信息，第二个参数为特殊情况下将要调用的函数的地址值（指针）。发生第一个参数代表的情况时，调用第二个参数所指的函数。下面给出可以在 signal 函数中注册的部分特殊情况和对应的函数。</p>
<ul>
<li>SIGALRM：已到通过调用 alarm 函数注册时间</li>
<li>SIGINT：输入 ctrl+c</li>
<li>SIGCHLD：子进程终止</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br><span class="line"><span class="comment">// 返回0或以秒为单位的距 SIGALRM 信号发生所剩时间</span></span><br></pre></td></tr></table></figure>
<h2 id="利用-sigaction-函数进行信号处理"><a href="#利用-sigaction-函数进行信号处理" class="headerlink" title="利用 sigaction 函数进行信号处理"></a>利用 sigaction 函数进行信号处理</h2><p>前面所学的内容可以防止僵尸进程，还有一个函数，叫做 sigaction 函数，他类似于 signal 函数，而且可以完全代替后者，也更稳定。之所以稳定，是因为：</p>
<blockquote>
<p>signal 函数在 Unix 系列的不同操作系统可能存在区别，但 sigaction 函数完全相同</p>
</blockquote>
<p>实际上现在很少用 signal 函数编写程序，他只是为了保持对旧程序的兼容，下面介绍 sigaction 函数，只讲解可以替换 signal 函数的功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signo, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">act: 对于第一个参数的信号处理函数（信号处理器）信息。</span></span><br><span class="line"><span class="comment">oldact: 通过此参数获取之前注册的信号处理函数指针，若不需要则传递 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>声明并初始化 sigaction 结构体变量以调用上述函数，该结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">    <span class="type">int</span> sa_flags;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此结构体的成员 sa_handler 保存信号处理的函数指针值（地址值）。sa_mask 和 sa_flags 的所有位初始化 0 即可。这 2 个成员用于指定信号相关的选项和特性，而我们的目的主要是防止产生僵尸进程，故省略。</p>
<h1 id="第-11-章-进程间通信"><a href="#第-11-章-进程间通信" class="headerlink" title="第 11 章 进程间通信"></a>第 11 章 进程间通信</h1><p>创建管道的函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> filedes[<span class="number">2</span>])</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回 0 ，失败时返回 -1</span></span><br><span class="line"><span class="comment">filedes[0]: 通过管道接收数据时使用的文件描述符，即管道出口</span></span><br><span class="line"><span class="comment">filedes[1]: 通过管道传输数据时使用的文件描述符，即管道入口</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> BUF_SIZE 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str1[]=<span class="string">&quot;who are you&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[]=<span class="string">&quot;thank you for yur message&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fds1[<span class="number">2</span>],fds2[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pipe(fds1);</span><br><span class="line">    pipe(fds2);</span><br><span class="line">    pid=fork();</span><br><span class="line">    <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        write(fds1[<span class="number">1</span>],str1,<span class="keyword">sizeof</span>(str1));</span><br><span class="line">        read(fds2[<span class="number">0</span>],message,BUF_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child : %s\n&quot;</span>,message);</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        read(fds1[<span class="number">0</span>],message,BUF_SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;father : %s\n&quot;</span>,message);</span><br><span class="line">        write(fds2[<span class="number">1</span>],str2,<span class="keyword">sizeof</span>(str2));</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第-12-章-I-O-复用"><a href="#第-12-章-I-O-复用" class="headerlink" title="第 12 章 I/O 复用"></a>第 12 章 I/O 复用</h1><h2 id="设置检查（监视）范围及超时"><a href="#设置检查（监视）范围及超时" class="headerlink" title="设置检查（监视）范围及超时"></a>设置检查（监视）范围及超时</h2><p>下面是 select 函数的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> maxfd, fd_set *readset, fd_set *writeset,</span></span><br><span class="line"><span class="params">           fd_set *exceptset, <span class="type">const</span> <span class="keyword">struct</span> timeval *timeout)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回大于 0 的值，失败时返回 -1</span></span><br><span class="line"><span class="comment">maxfd: 监视对象文件描述符数量</span></span><br><span class="line"><span class="comment">readset: 将所有关注「是否存在待读取数据」的文件描述符注册到 fd_set 型变量，并传递其地址值。</span></span><br><span class="line"><span class="comment">writeset: 将所有关注「是否可传输无阻塞数据」的文件描述符注册到 fd_set 型变量，并传递其地址值。</span></span><br><span class="line"><span class="comment">exceptset: 将所有关注「是否发生异常」的文件描述符注册到 fd_set 型变量，并传递其地址值。</span></span><br><span class="line"><span class="comment">timeout: 调用 select 函数后，为防止陷入无限阻塞的状态，传递超时(time-out)信息</span></span><br><span class="line"><span class="comment">返回值: 发生错误时返回 -1,超时时返回0,。因发生关注的时间返回时，返回大于0的值，该值是发生事件的文件描述符数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>timeval 结构体定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> tv_sec;</span><br><span class="line">    <span class="type">long</span> tv_usec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>FD_ZERO(fd_set <em>fdset): 将 fdset 变量中的所有位初始化为 0<br>FD_SET(int fd,fd_set</em> fdset): 将 fd 所指定的文件描述符注册到 fdset 变量中<br>FD_ISSET(int fd,fd_set <em>fdset): 判断 fd 所指定的文件描述符是否在 fdset 变量中注册<br>FD_CLR(int fd,fd_set</em> fdset): 将 fd 所指定的文件描述符从 fdset 变量中注销</p>
<h2 id="select-函数的示例"><a href="#select-函数的示例" class="headerlink" title="select 函数的示例"></a>select 函数的示例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    fd_set reads,temp;</span><br><span class="line">    <span class="type">int</span> str_len,result;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    FD_ZERO(&amp;reads);</span><br><span class="line">    FD_SET(<span class="number">0</span>,&amp;reads);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=reads;</span><br><span class="line">        timeout.tv_sec=<span class="number">5</span>;</span><br><span class="line">        timeout.tv_usec=<span class="number">0</span>;</span><br><span class="line">        result=select(<span class="number">1</span>,&amp;temp,<span class="number">0</span>,<span class="number">0</span>,&amp;timeout);</span><br><span class="line">        <span class="keyword">if</span>(result==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;select() error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(result==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;TIME OUT!!!&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            str_len=read(<span class="number">0</span>,message,BUF_SIZE);<span class="comment">//read的第一个参数为文件描述符，在linux即为套接字</span></span><br><span class="line">                                             <span class="comment">//在在 UNIX/Linux 系统中，标准输入（stdin）的文件描述符就是 0，</span></span><br><span class="line">                                             <span class="comment">//标准输出（stdout）是 1，标准错误（stderr）是 2</span></span><br><span class="line">            message[str_len]=<span class="number">0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;message from console: %s&quot;</span>,message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="I-O-复用服务器示例"><a href="#I-O-复用服务器示例" class="headerlink" title="I/O 复用服务器示例"></a>I/O 复用服务器示例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span>* message)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock,clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> clnt_addr_size;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    fd_set reads,temp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span></span><br><span class="line">    <span class="type">int</span> fd_max,str_len,fd_num;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port=htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(serv_sock,(<span class="keyword">struct</span> sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(listen(serv_sock,<span class="number">5</span>)==<span class="number">-1</span>)error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    FD_ZERO(&amp;reads);</span><br><span class="line">    FD_SET(serv_sock,&amp;reads);</span><br><span class="line">    fd_max=serv_sock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp=reads;</span><br><span class="line">        timeout.tv_sec=<span class="number">5</span>;</span><br><span class="line">        timeout.tv_usec=<span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((fd_num=select(fd_max+<span class="number">1</span>,&amp;temp,<span class="number">0</span>,<span class="number">0</span>,&amp;timeout))==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(fd_num==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;TIME OUT!!!&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;fd_max+<span class="number">1</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET(i,&amp;temp))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==serv_sock)</span><br><span class="line">                &#123;</span><br><span class="line">                    clnt_addr_size=<span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">                    clnt_sock=accept(serv_sock,(<span class="keyword">struct</span> sockaddr*)&amp;clnt_addr,&amp;clnt_addr_size);</span><br><span class="line">                    FD_SET(clnt_sock,&amp;reads);</span><br><span class="line">                    <span class="keyword">if</span>(fd_max&lt;clnt_sock)fd_max=clnt_sock;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;connected client: %d \n&quot;</span>,clnt_sock);</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    str_len=read(i,message,BUF_SIZE);</span><br><span class="line">                    <span class="keyword">if</span>(str_len==<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        FD_CLR(i,&amp;reads);</span><br><span class="line">                        close(i);</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;close client : %d \n&quot;</span>,i);</span><br><span class="line">                    &#125;<span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        write(i,message,str_len);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span>* message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="第-13-章-多种-I-O-函数"><a href="#第-13-章-多种-I-O-函数" class="headerlink" title="第 13 章 多种 I/O 函数"></a>第 13 章 多种 I/O 函数</h1><h2 id="send-amp-recv-函数"><a href="#send-amp-recv-函数" class="headerlink" title="send &amp; recv 函数"></a>send &amp; recv 函数</h2><p>sned 函数定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回发送的字节数，失败时返回 -1</span></span><br><span class="line"><span class="comment">sockfd: 表示与数据传输对象的连接的套接字和文件描述符</span></span><br><span class="line"><span class="comment">buf: 保存待传输数据的缓冲地址值</span></span><br><span class="line"><span class="comment">nbytes: 待传输字节数</span></span><br><span class="line"><span class="comment">flags: 传输数据时指定的可选项信息</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>下面是 recv 函数的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> nbytes, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回接收的字节数（收到 EOF 返回 0），失败时返回 -1</span></span><br><span class="line"><span class="comment">sockfd: 表示数据接受对象的连接的套接字文件描述符</span></span><br><span class="line"><span class="comment">buf: 保存接受数据的缓冲地址值</span></span><br><span class="line"><span class="comment">nbytes: 可接收的最大字节数</span></span><br><span class="line"><span class="comment">flags: 接收数据时指定的可选项参数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>send 和 recv 函数的最后一个参数是收发数据的可选项，该选项可以用位或（bit OR）运算符（| 运算符）同时传递多个信息。</p>
<p>send &amp; recv 函数的可选项意义：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>可选项（Option）</th>
<th>含义</th>
<th>send</th>
<th>recv</th>
</tr>
</thead>
<tbody>
<tr>
<td>MSG_OOB</td>
<td>用于传输带外数据（Out-of-band data）</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>MSG_PEEK</td>
<td>验证输入缓冲中是否存在接受的数据</td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td>MSG_DONTROUTE</td>
<td>数据传输过程中不参照本地路由（Routing）表，在本地（Local）网络中寻找目的地</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>MSG_DONTWAIT</td>
<td>调用 I/O 函数时不阻塞，用于使用非阻塞（Non-blocking）I/O</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>MSG_WAITALL</td>
<td>防止函数返回，直到接收到全部请求的字节数</td>
<td>X</td>
<td>O</td>
</tr>
</tbody>
</table>
</div>
<h2 id="readv-amp-writev-函数"><a href="#readv-amp-writev-函数" class="headerlink" title="readv &amp; writev 函数"></a>readv &amp; writev 函数</h2><p>通过 writev 函数可以将分散保存在多个缓冲中的数据一并发送，通过 readv 函数可以由多个缓冲分别接收。因此，适用这 2 个函数可以减少 I/O 函数的调用次数。下面先介绍 writev 函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> filedes, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回发送的字节数，失败时返回 -1</span></span><br><span class="line"><span class="comment">filedes: 表示数据传输对象的套接字文件描述符。但该函数并不仅限于套接字，因此，可以像 read 一样向向其传递文件或标准输出描述符.</span></span><br><span class="line"><span class="comment">iov: iovec 结构体数组的地址值，结构体 iovec 中包含待发送数据的位置和大小信息</span></span><br><span class="line"><span class="comment">iovcnt: 向第二个参数传递数组长度</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上述第二个参数中出现的数组 iovec 结构体的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span> *iov_base; <span class="comment">//缓冲地址</span></span><br><span class="line">    <span class="type">size_t</span> iov_len; <span class="comment">//缓冲大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面介绍 readv 函数，功能和 writev 函数正好相反.函数为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> filedes, <span class="type">const</span> <span class="keyword">struct</span> iovc *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回接收的字节数，失败时返回 -1</span></span><br><span class="line"><span class="comment">filedes: 表示数据传输对象的套接字文件描述符。但该函数并不仅限于套接字，因此，可以像 write 一样向向其传递文件或标准输出描述符.</span></span><br><span class="line"><span class="comment">iov: iovec 结构体数组的地址值，结构体 iovec 中包含待数据保存的位置和大小信息</span></span><br><span class="line"><span class="comment">iovcnt: 第二个参数中数组的长度</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h1 id="第-14-章-多播与广播"><a href="#第-14-章-多播与广播" class="headerlink" title="第 14 章 多播与广播"></a>第 14 章 多播与广播</h1><h2 id="多播"><a href="#多播" class="headerlink" title="多播"></a>多播</h2><h3 id="路由和-TTL（Time-to-Live-生存时间），以及加入组的办法"><a href="#路由和-TTL（Time-to-Live-生存时间），以及加入组的办法" class="headerlink" title="路由和 TTL（Time to Live,生存时间），以及加入组的办法"></a>路由和 TTL（Time to Live,生存时间），以及加入组的办法</h3><p>为了传递多播数据包，必须设置 TTL 。TTL 是 Time to Live的简写，是决定「数据包传递距离」的主要因素。TTL 用整数表示，并且每经过一个路由器就减一。TTL 变为 0 时，该数据包就无法再被传递，只能销毁。因此，TTL 的值设置过大将影响网络流量。当然，设置过小，也无法传递到目标。</p>
<p>接下来是 TTL 的设置方法。TTL 是可以通过第九章的套接字可选项完成的。与设置 TTL 相关的协议层为 IPPROTO_IP ，选项名为 IP_MULTICAST_TTL。因此，可以用如下代码把 TTL 设置为 64</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> send_sock;</span><br><span class="line"><span class="type">int</span> time_live = <span class="number">64</span>;</span><br><span class="line">...</span><br><span class="line">send_sock=socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">setsockopt(send_sock,IPPROTO_IP,IP_MULTICAST_TTL,(<span class="type">void</span>*)&amp;time_live,<span class="keyword">sizeof</span>(time_live);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>加入多播组也通过设置套接字可选项来完成。加入多播组相关的协议层为 IPPROTO_IP，选项名为 IP_ADD_MEMBERSHIP 。可通过如下代码加入多播组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> recv_sock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">join_adr</span>;</span></span><br><span class="line">...</span><br><span class="line">recv_sock=socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">join_adr.imr_multiaddr.s_addr=<span class="string">&quot;多播组地址信息&quot;</span>;</span><br><span class="line">join_adr.imr_interface.s_addr=<span class="string">&quot;加入多播组的主机地址信息&quot;</span>;</span><br><span class="line">setsockopt(recv_sock,IPPROTO_IP,IP_ADD_MEMBERSHIP,(<span class="type">void</span>*)&amp;join_adr,<span class="keyword">sizeof</span>(join_adr);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>下面是 ip_mreq 结构体的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_multiaddr</span>;</span> <span class="comment">//写入加入组的IP地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">imr_interface</span>;</span> <span class="comment">//加入该组的套接字所属主机的IP地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="发送方示例"><a href="#发送方示例" class="headerlink" title="发送方示例"></a>发送方示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TLL 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handling_error</span><span class="params">(<span class="type">char</span>* message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> send_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">mul_adr</span>;</span></span><br><span class="line">    <span class="type">int</span> time_live=TLL;</span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;GroupIP&gt; &lt;Port&gt;\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    send_sock=socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;mul_adr,<span class="number">0</span>,<span class="keyword">sizeof</span>(mul_adr));</span><br><span class="line">    mul_adr.sin_family=AF_INET;</span><br><span class="line">    mul_adr.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    mul_adr.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    setsockopt(send_sock,IPPROTO_IP,IP_MULTICAST_TTL,(<span class="type">void</span>*)&amp;time_live,<span class="keyword">sizeof</span>(time_live));</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;news.txt&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">        handling_error(<span class="string">&quot;fopen() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!feof(fp))</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf,BUF_SIZE,fp);</span><br><span class="line">        sendto(send_sock,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;mul_adr,<span class="keyword">sizeof</span>(mul_adr));</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    close(send_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handling_error</span><span class="params">(<span class="type">char</span>* message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收方示例"><a href="#接收方示例" class="headerlink" title="接收方示例"></a>接收方示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handling_error</span><span class="params">(<span class="type">char</span>* message)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> recv_sock;</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">join_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ip_mreq</span> <span class="title">join_adr</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handling_error</span><span class="params">(<span class="type">char</span>* message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h2><h3 id="发送方示例-1"><a href="#发送方示例-1" class="headerlink" title="发送方示例"></a>发送方示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handling_error</span><span class="params">(<span class="type">char</span>* message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> send_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">mul_adr</span>;</span></span><br><span class="line">    FILE* fp;</span><br><span class="line">    <span class="type">int</span> so_brd=<span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;GroupIP&gt; &lt;Port&gt;\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    send_sock=socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;mul_adr,<span class="number">0</span>,<span class="keyword">sizeof</span>(mul_adr));</span><br><span class="line">    mul_adr.sin_family=AF_INET;</span><br><span class="line">    mul_adr.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    mul_adr.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    setsockopt(send_sock,SOL_SOCKET,SO_BROADCAST,(<span class="type">void</span>*)&amp;so_brd,<span class="keyword">sizeof</span>(so_brd));</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;news.txt&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">        handling_error(<span class="string">&quot;fopen() error&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!feof(fp))</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf,BUF_SIZE,fp);</span><br><span class="line">        sendto(send_sock,buf,<span class="built_in">strlen</span>(buf),<span class="number">0</span>,(<span class="keyword">struct</span> sockaddr*)&amp;mul_adr,<span class="keyword">sizeof</span>(mul_adr));</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line">    close(send_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">handling_error</span><span class="params">(<span class="type">char</span>* message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收方示例-1"><a href="#接收方示例-1" class="headerlink" title="接收方示例"></a>接收方示例</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span>* message)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 30</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> recv_sock;</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line">    <span class="type">char</span> buf[BUF_SIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">adr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    recv_sock=socket(PF_INET,SOCK_DGRAM,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;adr,<span class="number">0</span>,<span class="keyword">sizeof</span>(adr));</span><br><span class="line">    adr.sin_family=AF_INET;</span><br><span class="line">    adr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">    adr.sin_port=htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(recv_sock,(<span class="keyword">struct</span> sockaddr*)&amp;adr,<span class="keyword">sizeof</span>(adr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str_len=recvfrom(recv_sock,buf,BUF_SIZE<span class="number">-1</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(str_len&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        buf[str_len]=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">fputs</span>(buf,<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(recv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span>* message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="套接字和标准I-O"><a href="#套接字和标准I-O" class="headerlink" title="套接字和标准I/O"></a>套接字和标准I/O</h1><h2 id="标准I-O的优点"><a href="#标准I-O的优点" class="headerlink" title="标准I/O的优点"></a>标准I/O的优点</h2><ul>
<li>标准 I/O 函数具有良好的移植性</li>
<li>标准 I/O 函数可以利用缓冲提高性能</li>
</ul>
<h2 id="标准I-O的缺点"><a href="#标准I-O的缺点" class="headerlink" title="标准I/O的缺点"></a>标准I/O的缺点</h2><ul>
<li>不容易进行双向通信</li>
<li>有时可能频繁调用 fflush 函数</li>
<li>需要以 FILE 结构体指针的形式返回文件描述符。</li>
</ul>
<h2 id="利用-fdopen-函数转换为-FILE-结构体指针"><a href="#利用-fdopen-函数转换为-FILE-结构体指针" class="headerlink" title="利用 fdopen 函数转换为 FILE 结构体指针"></a>利用 fdopen 函数转换为 FILE 结构体指针</h2><p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">FILE *<span class="title function_">fdopen</span><span class="params">(<span class="type">int</span> fildes, <span class="type">const</span> <span class="type">char</span> *mode)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回转换的 FILE 结构体指针，失败时返回 NULL</span></span><br><span class="line"><span class="comment">fildes ： 需要转换的文件描述符</span></span><br><span class="line"><span class="comment">mode ： 将要创建的 FILE 结构体指针的模式信息</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="利用-fileno-函数转换为文件描述符"><a href="#利用-fileno-函数转换为文件描述符" class="headerlink" title="利用 fileno 函数转换为文件描述符"></a>利用 fileno 函数转换为文件描述符</h2><p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fileno</span><span class="params">(FILE *stream)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成功时返回文件描述符，失败时返回 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE * fp;</span><br><span class="line">    <span class="type">int</span> fd=open(<span class="string">&quot;old.txt&quot;</span>,O_WRONLY|O_CREAT|O_TRUNC);</span><br><span class="line">    <span class="keyword">if</span>(fd==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;file open error&quot;</span>,<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fp=fdopen(fd,<span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First file description is %d \n&quot;</span>,fd);</span><br><span class="line">    <span class="built_in">fputs</span>(<span class="string">&quot;Network C programming \n&quot;</span>,fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Second file description is %d \n&quot;</span>,fileno(fp));</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于套接字的标准-I-O-函数使用"><a href="#基于套接字的标准-I-O-函数使用" class="headerlink" title="基于套接字的标准 I/O 函数使用"></a>基于套接字的标准 I/O 函数使用</h2><h3 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span>* message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> serv_sock,clnt_sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>,<span class="title">clnt_addr</span>;</span></span><br><span class="line">    FILE* readfp ,*writefp;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line">    <span class="type">socklen_t</span> clnt_addr_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serv_sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(serv_sock==<span class="number">-1</span>)error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">    serv_addr.sin_port=htons(atoi(argv[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bind(serv_sock,(<span class="keyword">struct</span> sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)</span><br><span class="line">        error_handling(<span class="string">&quot;bind() error&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(listen(serv_sock,<span class="number">5</span>)==<span class="number">-1</span>) error_handling(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    clnt_addr_size=<span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        clnt_sock=accept(serv_sock,(<span class="keyword">struct</span> sockaddr*)&amp;clnt_addr,&amp;clnt_addr_size);</span><br><span class="line">        <span class="keyword">if</span>(clnt_sock==<span class="number">-1</span>)error_handling(<span class="string">&quot;accept() error&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Connected client %d \n&quot;</span>,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        readfp=fdopen(clnt_sock,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        writefp=fdopen(clnt_sock,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!feof(readfp))</span><br><span class="line">        &#123;</span><br><span class="line">            fgets(message,BUF_SIZE,readfp);</span><br><span class="line">            <span class="built_in">fputs</span>(message,writefp);</span><br><span class="line">            fflush(writefp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fclose(readfp);</span><br><span class="line">        fclose(writefp);</span><br><span class="line">    &#125;</span><br><span class="line">    close(serv_sock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span>* message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span>* message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    FILE* readfp ,*writefp;</span><br><span class="line">    <span class="type">char</span> message[BUF_SIZE];</span><br><span class="line">    <span class="type">int</span> str_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;port&gt;\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sock==<span class="number">-1</span>)error_handling(<span class="string">&quot;socket() error&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr,<span class="number">0</span>,<span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family=AF_INET;</span><br><span class="line">    serv_addr.sin_addr.s_addr=inet_addr(argv[<span class="number">1</span>]);</span><br><span class="line">    serv_addr.sin_port=htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(connect(sock,(<span class="keyword">struct</span> sockaddr*)&amp;serv_addr,<span class="keyword">sizeof</span>(serv_addr))==<span class="number">-1</span>)error_handling(<span class="string">&quot;connect() error&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Connect ............\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    readfp=fdopen(sock,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    writefp=fdopen(sock,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">&quot;Input message(Q to quit): &quot;</span>, <span class="built_in">stdout</span>);</span><br><span class="line">        fgets(message, BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(message, <span class="string">&quot;q\n&quot;</span>) || !<span class="built_in">strcmp</span>(message, <span class="string">&quot;Q\n&quot;</span>))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">fputs</span>(message,writefp);</span><br><span class="line">        fflush(writefp);</span><br><span class="line">        fgets(message,BUF_SIZE,readfp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Message from server: %s&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(writefp);</span><br><span class="line">    fclose(readfp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">error_handling</span><span class="params">(<span class="type">char</span>* message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message,<span class="built_in">stderr</span>);</span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>,<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>gdb</title>
    <url>/uncategorized/tool/gdb/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计时提醒器</title>
    <url>/uncategorized/tool/study/</url>
    <content><![CDATA[<h1 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h1><h2 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h2><ol>
<li>计时1.5小时</li>
<li>期间任意3-5分钟会播放叮的一声</li>
<li>播放结束后会播放一个提示音</li>
</ol>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li><p>SDL_Mixer:支持wav格式,自己找两个替换bing.wav,over.wav,可以到这里找: <a href="https://freesound.org/">https://freesound.org/</a></p>
</li>
<li><p>linux-ubuntu下载：sudo apt-get install libsdl2-mixer-dev</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="work-hpp"><a href="#work-hpp" class="headerlink" title="work.hpp"></a>work.hpp</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include &lt;SDL2/SDL.h&gt;</span><br><span class="line"># include &lt;SDL2/SDL_mixer.h&gt;</span><br><span class="line"># include &lt;chrono&gt;</span><br><span class="line"># include &lt;cmath&gt;</span><br><span class="line"># include &lt;cstdlib&gt;</span><br><span class="line"># include &lt;functional&gt;</span><br><span class="line"># include &lt;iomanip&gt;</span><br><span class="line"># include &lt;iostream&gt;</span><br><span class="line"># include &lt;random&gt;</span><br><span class="line"># include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">// 类型别名</span><br><span class="line">using Clock      = std::chrono::steady_clock;</span><br><span class="line">using TimePoint  = Clock::time_point;</span><br><span class="line">using Seconds    = std::chrono::seconds;</span><br><span class="line">using Minutes    = std::chrono::minutes;</span><br><span class="line">using Hours      = std::chrono::hours;</span><br><span class="line"></span><br><span class="line">class mytool&#123;</span><br><span class="line">public:</span><br><span class="line">    Seconds pick_random_delay();</span><br><span class="line">    void init(Mix_Chunk* &amp;over,Mix_Chunk* &amp;bing);</span><br><span class="line">    void test1(Mix_Chunk* bing);</span><br><span class="line">    void test2(Mix_Chunk* over);</span><br><span class="line">    void run();</span><br><span class="line">private:</span><br><span class="line">    Mix_Chunk* over, *bing;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="tool-cpp"><a href="#tool-cpp" class="headerlink" title="tool.cpp"></a>tool.cpp</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include &quot;work.hpp&quot;</span><br><span class="line"></span><br><span class="line">// 生成一个 [180, 300] 秒的随机延迟</span><br><span class="line">Seconds mytool::pick_random_delay() &#123;</span><br><span class="line">    static std::random_device rd;</span><br><span class="line">    static std::mt19937       gen(rd());</span><br><span class="line">    std::uniform_int_distribution&lt;&gt; dist(180, 300);</span><br><span class="line">    return Seconds(dist(gen));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mytool::init(Mix_Chunk* &amp;over,Mix_Chunk* &amp;bing)</span><br><span class="line">&#123;</span><br><span class="line">    // 初始化 SDL 和 SDL_Mixer</span><br><span class="line">    if (SDL_Init(SDL_INIT_AUDIO) &lt; 0) &#123;</span><br><span class="line">        printf(&quot;SDL初始化失败: %s\n&quot;, SDL_GetError());</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (Mix_OpenAudio(44100, AUDIO_S16SYS, 2, 4096) &lt; 0) &#123;</span><br><span class="line">        printf(&quot;音频设备初始化失败: %s\n&quot;, Mix_GetError());</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //加载 WAV 文件</span><br><span class="line">    over=Mix_LoadWAV(&quot;over.wav&quot;);</span><br><span class="line">    if (!over) &#123;</span><br><span class="line">        printf(&quot;加载over音频失败: %s\n&quot;, Mix_GetError());</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    bing=Mix_LoadWAV(&quot;bing.wav&quot;);</span><br><span class="line">    if (!bing) &#123;</span><br><span class="line">        printf(&quot;加载bing音频失败: %s\n&quot;, Mix_GetError());</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mytool::test1(Mix_Chunk* bing)</span><br><span class="line">&#123;</span><br><span class="line">    Mix_PlayChannel(0, bing, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mytool::test2(Mix_Chunk* over)</span><br><span class="line">&#123;</span><br><span class="line">    Mix_PlayChannel(0, over, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mytool::run()</span><br><span class="line">&#123;</span><br><span class="line">    init(over,bing);</span><br><span class="line">    auto start       = Clock::now();</span><br><span class="line">    auto total_dur   = Hours(1) + Minutes(30);      // 1.5 小时</span><br><span class="line">    auto end_time    = start + total_dur;</span><br><span class="line">    auto task_delay  = pick_random_delay();</span><br><span class="line">    auto task_time   = start + task_delay;</span><br><span class="line">    while(true)</span><br><span class="line">    &#123;</span><br><span class="line">        auto now =Clock::now();</span><br><span class="line">        if(now&gt;=end_time)</span><br><span class="line">        &#123;</span><br><span class="line">            test2(over);</span><br><span class="line">            std::cout &lt;&lt;&quot;\n倒计时结束,程序退出。\n&quot;;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(now&gt;=task_time)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt;&quot;该休息10秒了,闭眼吧&quot;&lt;&lt;std::endl;</span><br><span class="line">            test1(bing);</span><br><span class="line">            task_delay  = pick_random_delay();</span><br><span class="line">            task_time = now + task_delay;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    mytool test;</span><br><span class="line">    test.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ul>
<li>编译：g++ tool.cpp -o work -lSDL2 -lSDL2_mixer</li>
</ul>
]]></content>
  </entry>
</search>
